esphome:
  name: rotary-phone-agent
  friendly_name: Rotary Phone Agent
  min_version: 2024.7.0
  includes:
    - src/rotary_helpers.h
  platformio_options:
    board_build.flash_mode: dio
    # LilyGO T7-S3 16MB Flash / 8MB PSRAM Specifics
    board_build.arduino.memory_type: qio_opi
    build_flags:
      - "-DBOARD_HAS_PSRAM"

# Hardware Pin Definitions
# Change these values here to adapt to different board revisions
substitutions:
  # I2S Audio - Handset (Microphone & Ear Speaker)
  pin_i2s_handset_lrclk: GPIO5
  pin_i2s_handset_bclk: GPIO6
  pin_i2s_handset_din: GPIO7   # Mic Data In
  pin_i2s_handset_dout: GPIO15 # Speaker Data Out

  # I2S Audio - Base (Main Speaker for Ringtone/Music)
  pin_i2s_base_lrclk: GPIO16
  pin_i2s_base_bclk: GPIO18
  pin_i2s_base_dout: GPIO19

  # Peripherals
  pin_led_strip: GPIO2
  pin_battery_voltage: GPIO4
  pin_uart_tx: GPIO43
  pin_uart_rx: GPIO44
  
  # I2C Bus
  pin_i2c_sda: GPIO8
  pin_i2c_scl: GPIO9

  # Rotary Phone Mechanism
  pin_hook_switch: GPIO1      # Detects if handset is on hook
  pin_dial_pulse: GPIO14      # Dial pulse counting
  pin_dial_active: GPIO13     # Active while dial is rotating
  
  # Speed Dial Buttons
  pin_button_1: GPIO10
  pin_button_2: GPIO11
  pin_button_3: GPIO12
  pin_button_4: GPIO21 # Adjust if necessary

# External Components
external_components:
  - source: components
    components: [ drv2605, vintage_tone_generator ]

esp32:
  board: esp32-s3-devkitc-1
  flash_size: 16MB
  partitions: default_16MB.csv
  framework:
    type: arduino

# Enable logging
logger:

# Enable debug component
debug:

# Enable Home Assistant API
api:
  reboot_timeout: 5min
  services:
    - service: start_find_my_phone
      then:
        - script.execute: find_phone
    - service: stop_find_my_phone
      then:
        - script.stop: find_phone
        - light.turn_off: button_leds
    - service: start_broadcast_notification
      then:
        - light.turn_on:
            id: button_leds
            effect: "Broadcast Pulse"
    - service: stop_broadcast_notification
      then:
        - light.turn_off: button_leds

# Enable OTA updates
ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  reboot_timeout: 5min

  # Captive Portal Fallback
  ap:
    ssid: "Rotary-Phone-Agent Fallback"
    password: "" # Consider moving this to secrets if security is a concern

captive_portal:

# Voice Assistant configuration
# Requires a microphone and speaker (e.g., I2S based like INMP441 and MAX98357A)

# I2S Bus A: Handset
i2s_audio:
  - id: i2s_bus_handset
    i2s_lrclk_pin: ${pin_i2s_handset_lrclk}
    i2s_bclk_pin: ${pin_i2s_handset_bclk}

  # I2S Bus B: Base Speaker
  - id: i2s_bus_base
    i2s_lrclk_pin: ${pin_i2s_base_lrclk}
    i2s_bclk_pin: ${pin_i2s_base_bclk}

microphone:
  - platform: i2s_audio
    id: mic_i2s
    i2s_audio_id: i2s_bus_handset
    i2s_din_pin: ${pin_i2s_handset_din}
    adc_type: external
    pdm: false

vintage_tone_generator:
  id: my_tone_gen
  i2s_audio_id: i2s_bus_handset

speaker:
  # Handset Speaker (Standard for Voice Assistant)
  - platform: i2s_audio
    id: speaker_handset
    i2s_audio_id: i2s_bus_handset
    i2s_dout_pin: ${pin_i2s_handset_dout}
    dac_type: external

# Media Player for Ringtones & Music (Base Speaker)
media_player:
  - platform: i2s_audio
    name: "Rotary Phone Base Speaker"
    id: media_player_base
    i2s_audio_id: i2s_bus_base
    i2s_dout_pin: ${pin_i2s_base_dout}
    dac_type: external
    mode: mono
    on_play:
      - light.turn_on: button_leds
      - light.addressable_set:
          id: button_leds
          range_from: 0
          range_to: 4
          red: 0%
          green: 0%
          blue: 100% # Blue for Music/Ringing
    on_idle:
      - light.turn_off: button_leds

voice_assistant:
  microphone: mic_i2s
  speaker: speaker_handset # Respond only via Handset
  on_start:
    - if:
        condition:
          switch.is_on: mic_mute
        then:
          - voice_assistant.stop:
          - logger.log: "Voice Assistant blocked because of Mute"
          - light.turn_on:
              id: button_leds
              effect: "Mute Pulse"
        else:
          - light.turn_on:
              id: button_leds
              effect: "none"
          - light.addressable_set:
              id: button_leds
              range_from: 0
              range_to: 1
              red: 0%
              green: 0%
              blue: 0%
          # Fade Green In
          - light.addressable_set:
              id: button_leds
              range_from: 0
              range_to: 1
              red: 0%
              green: 20%
              blue: 0%
          - delay: 100ms
          - light.addressable_set:
              id: button_leds
              range_from: 0
              range_to: 1
              red: 0%
              green: 60%
              blue: 0%
          - delay: 100ms
          - light.addressable_set:
              id: button_leds
              range_from: 0
              range_to: 1
              red: 0%
              green: 100%
              blue: 0%

  on_stt_end:
    - light.turn_on: 
        id: button_leds
        effect: "Thinking Pulse"

  on_tts_start:
    # Speaking - optionally dim or off. "Off to allow conversation"
    - light.turn_off: button_leds

  on_end:
    # Busy Tone after call (425Hz, 480ms ON, 480ms OFF)
    - lambda: |-
        id(my_tone_gen).set_pulse_timing(480, 480);
        id(my_tone_gen).start_tone(425.0, true);
    - light.turn_off: button_leds

  on_error:
    - light.turn_on: 
        id: button_leds
        effect: "Error Pulse"
    - delay: 2s
    - light.turn_off: button_leds

# Button LEDs
light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: ${pin_led_strip}
    num_leds: 4
    chipset: ws2812
    name: "Button LEDs"
    id: button_leds
    restore_mode: ALWAYS_OFF
    
    # Simulates incandescent fading (Gamma/Tungsten)
    default_transition_length: 0s 

    effects:
      - addressable_scan:
      
      # Mute Pulse (Purple on LED 2 - Index 1)
      - addressable_lambda:
          name: "Mute Pulse"
          update_interval: 50ms # 20fps for smooth animation
          lambda: |-
            static float progress = 0.0;
            static float direction = 0.05;
            
            // Sine-wave approximation for incandescent feel
            progress += direction;
            if (progress > 1.0) { progress = 1.0; direction = -0.05; }
            if (progress < 0.1) { progress = 0.1; direction = 0.05; }
            
            float brightness = progress * progress; // Gamma correctionish
            it.all() = Color::BLACK;
            if (it.size() > 1) it[1] = Color(128, 0, 128) * brightness;

      # Thinking Pulse (Blue on LED 1 - Index 0)
      - addressable_lambda:
          name: "Thinking Pulse"
          update_interval: 50ms
          lambda: |-
            static float progress = 0.0;
            static float direction = 0.1;
            
            progress += direction;
            if (progress > 1.0) { progress = 1.0; direction = -0.05; } // Fast on
            if (progress < 0.0) { progress = 0.0; direction = 0.05; }  // Slow off
            
            float brightness = progress * progress; 
            it.all() = Color::BLACK;
            if (it.size() > 0) it[0] = Color(0, 0, 255) * brightness;

      # Error Pulse (Red on LED 1 - Index 0)
      - addressable_lambda:
          name: "Error Pulse"
          update_interval: 50ms
          lambda: |-
            static float progress = 0.0;
            static float direction = 0.2; // Faster blink
            
            progress += direction;
            if (progress > 1.0) { progress = 1.0; direction = -0.2; }
            if (progress < 0.0) { progress = 0.0; direction = 0.2; }
            
            float brightness = progress * progress;
            it.all() = Color::BLACK;
            if (it.size() > 0) it[0] = Color(255, 0, 0) * brightness;

      # Broadcast Pulse (Yellow on LED 4 - Index 3)
      - addressable_lambda:
          name: "Broadcast Pulse"
          update_interval: 50ms
          lambda: |-
            static float progress = 0.0;
            static float direction = 0.05;
            
            progress += direction;
            if (progress > 1.0) { progress = 1.0; direction = -0.05; }
            if (progress < 0.0) { progress = 0.0; direction = 0.05; }
            
            float brightness = progress * progress;
            it.all() = Color::BLACK;
            if (it.size() > 3) it[3] = Color(255, 200, 0) * brightness;

      # Battery Level Indicator (Static with fade-in on start)
      - addressable_lambda:
          name: "Battery Level"
          update_interval: 500ms
          lambda: |-
            float v = id(battery_voltage).state;
            it.all() = Color::BLACK;
            
            // LED 1 (Red) - < 3.6V (Critical/Low)
            if (v >= 3.0) it[0] = Color(255, 0, 0); 
            
            // LED 2 (Orange) - > 3.6V
            if (v >= 3.6) it[1] = Color(255, 165, 0);
            
            // LED 3 (Yellow) - > 3.8V
            if (v >= 3.8) it[2] = Color(255, 255, 0);
            
            // LED 4 (Green) - > 4.0V
            if (v >= 4.0) it[3] = Color(0, 255, 0);

# Bluetooth for Tracking
esp32_ble_tracker:
  scan_parameters:
    interval: 1100ms
    window: 1100ms
    active: true

bluetooth_proxy:
  active: true

# I2C Bus Sensoren
i2c:
  sda: ${pin_i2c_sda}
  scl: ${pin_i2c_scl}
  scan: true
  id: bus_a

# Haptic Motor Controller (DRV2605)
drv2605:
  i2c_id: bus_a
  id: haptic_motor
  motor_type: LRA       
  library: 6            # 6 = TS2200_F (LRA library)

# UART for DY-SV17F Audio Module
uart:
  - id: uart_bus_dfplayer
    tx_pin: ${pin_uart_tx}
    rx_pin: ${pin_uart_rx}
    baud_rate: 9600

# Sensors
sensor:
  - platform: adc
    pin: ${pin_battery_voltage}
    name: "Battery Voltage"
    id: battery_voltage
    update_interval: 60s
    attenuation: 12db
    filters:
      - multiply: 2.0 # Adjust voltage divider factor if needed
    on_value:
      then:
        - if:
            condition:
              lambda: 'return rotary::is_battery_low(x, id(low_battery_threshold).state);'
            then:
              - if:
                  condition:
                    not:
                      script.is_running: led_pulse_red_battery
                  then:
                    - script.execute: led_pulse_red_battery
                    - homeassistant.event:
                        event: esphome.rotary_phone_low_battery
                    - logger.log: "Battery Low! Starting alarm."
            else:
              - if:
                  condition:
                    script.is_running: led_pulse_red_battery
                  then:
                    - script.stop: led_pulse_red_battery
                    - light.addressable_set:
                        id: button_leds
                        range_from: 3
                        range_to: 4
                        red: 0%
                        green: 0%
                        blue: 0%
                    - logger.log: "Battery OK. Stopping alarm."

  - platform: template
    name: "Battery Level"
    id: battery_level
    unit_of_measurement: "%"
    device_class: battery
    accuracy_decimals: 0
    lambda: 'return rotary::get_battery_level(id(battery_voltage).state);'
    update_interval: 60s

  - platform: template
    name: "Last Dialed Digit"
    id: last_dialed_digit
    icon: "mdi:dialpad"
    accuracy_decimals: 0
    force_update: true

# Globals
globals:
  - id: dial_pulse_count
    type: int
    initial_value: '0'
  - id: hook_down_timestamp
    type: unsigned long
    initial_value: '0'
  - id: multi_digit_mode
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: dialed_number_buffer
    type: std::string
    restore_value: no
    initial_value: '""'
  - id: dial_string_timeout_ms
    type: int
    restore_value: yes
    initial_value: '3000'
  - id: is_muted
    type: bool
    restore_value: no
    initial_value: 'false'
  # Constants
  - id: vibe_loop_duration_ms
    type: int
    initial_value: '750' # 15 vibrations * 50ms

number:
  - platform: template
    name: "Low Battery Threshold"
    id: low_battery_threshold
    unit_of_measurement: "%"
    min_value: 5
    max_value: 50
    step: 1
    initial_value: 20
    optimistic: true
    restore_value: true

  - platform: template
    name: "Rotary Phone String Timeout"
    id: rotary_phone_string_timeout
    unit_of_measurement: "ms"
    min_value: 500
    max_value: 10000
    step: 100
    lambda: 'return id(dial_string_timeout_ms);'
    set_action:
      - globals.set:
          id: dial_string_timeout_ms
          value: !lambda 'return x;'

  - platform: template
    name: "Phone Volume"
    id: phone_volume
    icon: "mdi:volume-high"
    min_value: 0
    max_value: 30
    step: 1
    initial_value: 20
    optimistic: true
    restore_value: true
    set_action:
      - lambda: 'rotary::set_mp3_volume(id(uart_bus_dfplayer), x);'

  - platform: template
    name: "Ringtone Count"
    id: ring_count
    min_value: 1
    max_value: 20
    step: 1
    initial_value: 5
    optimistic: true
    restore_value: true

  - platform: template
    name: "Ringtone Duration"
    id: ring_duration
    unit_of_measurement: "ms"
    min_value: 1000
    max_value: 10000
    step: 100
    initial_value: 3000
    optimistic: true
    restore_value: true

  - platform: template
    name: "Ringtone Pause"
    id: ring_pause
    unit_of_measurement: "ms"
    min_value: 500
    max_value: 10000
    step: 100
    initial_value: 2000
    optimistic: true
    restore_value: true

switch:
  - platform: template
    name: "Microphone Mute"
    id: mic_mute
    icon: "mdi:microphone-off"
    optimistic: true
    on_turn_on:
      - light.turn_on:
          id: button_leds
          effect: "Mute Pulse"
    on_turn_off:
      - light.turn_off: button_leds

  - platform: template
    name: "Speakerphone Mode"
    id: speaker_mode
    icon: "mdi:volume-high"
    optimistic: true

  - platform: template
    name: "Do Not Disturb"
    id: dnd_mode
    icon: "mdi:minus-circle"
    optimistic: true

  - platform: template
    name: "Haptic Ringing"
    id: haptic_ringing
    icon: "mdi:vibrate"
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true

  - platform: template
    name: "Rotary Phone Multi-Digit Mode"
    id: rotary_phone_multi_digit_mode
    optimistic: true
    turn_on_action:
      - globals.set:
          id: multi_digit_mode
          value: 'true'
    turn_off_action:
      - globals.set:
          id: multi_digit_mode
          value: 'false'
      - script.execute: flush_dialed_number

select:
  - platform: template
    name: "Vibration Pattern"
    id: vibration_pattern
    options:
      - "Silent / Classic"
      - "Mechanical Bell"
    optimistic: true
    restore_value: true
    initial_option: "Silent / Classic"
    icon: "mdi:vibrate"

button:
  - platform: restart
    id: sys_restart
    name: "System Restart"

# Scripts
script:
  # Play MP3 via DY-SV17F (Play by File Number)
  - id: play_mp3
    parameters:
      file_num: int
    then:
      - lambda: 'rotary::play_mp3_file(id(uart_bus_dfplayer), file_num);'

  # Stop MP3 Playback
  - id: stop_mp3
    then:
      - uart.write: 
          id: uart_bus_dfplayer
          data: [0xAA, 0x04, 0x00, 0xAE]

  # Process and send dialed string
  - id: flush_dialed_number
    then:
      - if:
          condition:
            lambda: 'return id(dialed_number_buffer).length() > 0;'
          then:
            # Check for Magic Code "999" -> Reboot
            - if:
                condition:
                   lambda: 'return id(dialed_number_buffer) == "999";'
                then:
                   - logger.log: "Magic Code 999: System Reboot"
                   - button.press: sys_restart
                else:
                   - homeassistant.event:
                       event: esphome.rotary_phone_dial_string
                       data_template:
                         number: !lambda 'return id(dialed_number_buffer);'
                   - logger.log: 
                       format: "Dialed String sent: %s"
                       args: [ 'id(dialed_number_buffer).c_str()' ]
            - globals.set:
                id: dialed_number_buffer
                value: '""'

  - id: flush_dialed_number_timer
    mode: restart
    then:
      - delay: !lambda 'return id(dial_string_timeout_ms);'
      - script.execute: flush_dialed_number

  # Operator Simulation Script


  # Find My Phone Alarm
  - id: find_phone
    mode: restart
    then:
      - light.turn_on: button_leds
      - while:
          condition:
            lambda: 'return true;'
          then:
            # Visual Alarm (All LEDs flash red)
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 4
                red: 100%
                green: 0%
                blue: 0%
            - delay: 200ms
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 4
                red: 0%
                green: 0%
                blue: 0%
            - delay: 200ms

  - id: process_dialed_digit
    mode: restart
    then:
      - logger.log:
          format: "Rotary Dial: %d pulses counted"
          args: [ 'id(dial_pulse_count)' ]
      
      # Update sensor
      - sensor.template.publish:
          id: last_dialed_digit
          state: !lambda 'return (id(dial_pulse_count) == 10) ? 0 : id(dial_pulse_count);'

      - if:
          condition:
            lambda: 'return id(dial_pulse_count) > 0;'
          then:
            - if:
                condition:
                  lambda: 'return id(dial_pulse_count) > 20;'
                then:
                  - logger.log: "Ghost pulse detected (Count > 20), ignoring."
                else:
                  - if:
                      condition:
                        lambda: 'return id(multi_digit_mode);'
                      then:
                        # MULTI-DIGIT MODE
                        - lambda: |-
                            int digit = (id(dial_pulse_count) == 10) ? 0 : id(dial_pulse_count);
                            id(dialed_number_buffer) += std::to_string(digit);
                            ESP_LOGD("dial", "Digit added. Buffer: %s", id(dialed_number_buffer).c_str());
                        - script.stop: flush_dialed_number_timer
                        - script.execute: flush_dialed_number_timer
                      else:
                        # SINGLE DIGIT MODE
                        # Magic Code: 0 -> Start Voice Assistant Manual
                        - if:
                            condition:
                              lambda: 'return (id(dial_pulse_count) == 10);'
                            then:
                              - lambda: 'id(my_tone_gen).stop_tone();'
                              
                              # Start Ringback Tone (Pulsing: 1s ON, 4s OFF) in Handset
                              - lambda: 'id(my_tone_gen).start_tone(425.0, true);'
                              - logger.log: "Ringback Tone started (Handset)..."

                              # Check time since last conversation (hangup)
                              - if:
                                  condition:
                                    lambda: 'return (millis() - id(hook_down_timestamp)) > 60000;'
                                  then:
                                    # > 60s: Standard Mode (2-3 Rings)
                                    - logger.log: "Operator Mode: Standard (Gap > 60s)"
                                    - delay: !lambda 'return ((rand() % 2) + 2) * 5000;' 
                                    
                                    # Operator picks up -> Stop Ringing
                                    - lambda: 'id(my_tone_gen).stop_tone();'
                                    
                                    # Play Standard Greeting (Simulated by TTS Pause or Noise)
                                    - delay: 1s
                                    # Voice assistant already configured to answer politely via Prompt
                                    
                                    - voice_assistant.start:
                                  else:
                                    # < 60s: Annoyed Mode (1 Ring)
                                    - logger.log: "Operator Mode: Annoyed (Gap < 60s)"
                                    - delay: 5000ms
                                    
                                    # Operator picks up -> Stop Ringing
                                    - lambda: 'id(my_tone_gen).stop_tone();'

                                    # Play Annoyed Greeting (Simulated by TTS Pause or Noise)
                                    - delay: 500ms
                                    # Voice assistant configured to answer annoyed via Prompt
                                    
                                    - voice_assistant.start:
                            else:
                              - homeassistant.event:
                                  event: esphome.rotary_phone_dial
                                  data_template:
                                    digit: !lambda 'return (id(dial_pulse_count) == 10) ? 0 : id(dial_pulse_count);'
      
      - globals.set:
          id: dial_pulse_count
          value: '0'

  # Ringtone Sequence
  - id: ring_phone
    mode: restart
    then:
      - repeat:
          count: !lambda 'return id(ring_count).state;'
          then:
            # Check if phone is on hook
            - if:
                condition:
                  binary_sensor.is_on: phone_hook
                then:
                  # Play Audio
                  - if:
                      condition:
                         lambda: 'return id(phone_volume).state > 0;'
                      then:
                        - script.execute:
                            id: play_mp3
                            file_num: 1 # 00001.wav / .mp3
                  
                  # Vibration
                  - if:
                      condition:
                        switch.is_on: haptic_ringing
                      then:
                        - if:
                            condition:
                              lambda: 'return id(vibration_pattern).state == "Mechanical Bell";'
                            then:
                              - repeat:
                                  count: 25 # Faster, more aggressive for Bell mechanics (Total ~750ms)
                                  then:
                                    - drv2605.play_effect:
                                        id: haptic_motor
                                        effect: 1 # Strong Click
                                    - delay: 30ms
                            else:
                              - repeat:
                                  count: 15 # Classic / Silent (Total ~750ms)
                                  then:
                                    - drv2605.play_effect:
                                        id: haptic_motor
                                        effect: 1 # Strong Click
                                    - delay: 50ms

                  # Wait time compensations: ring_duration - actual_vibration_time
                  - delay: !lambda |-
                      int remaining = id(ring_duration).state - id(vibe_loop_duration_ms);
                      return (remaining < 0) ? 0 : remaining;
                  - delay: !lambda 'return id(ring_pause).state;'
                else:
                  - script.stop: ring_phone

  - id: led_pulse_red_battery
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return true;'
          then:
            # Fade in
            - light.addressable_set:
                id: button_leds
                range_from: 3
                range_to: 4
                red: 100%
                green: 0%
                blue: 0%
            - delay: 1000ms
            # Fade out
            - light.addressable_set:
                id: button_leds
                range_from: 3
                range_to: 4
                red: 10%
                green: 0%
                blue: 0%
            - delay: 1000ms

  - id: led_pulse_purple_mute
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return id(is_muted);'
          then:
            # Fade in (Purple)
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 1
                red: 50%
                green: 0%
                blue: 50%
            - delay: 1000ms
            # Fade out
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 1
                red: 10%
                green: 0%
                blue: 10%
            - delay: 1000ms

# Binary Sensors
binary_sensor:
  # Hook Switch (Is phone on hook?)
  - platform: gpio
    pin:
      number: ${pin_hook_switch}
      mode: INPUT_PULLUP
      inverted: true
    name: "Phone Hook"
    id: phone_hook
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      # Hook Down (Call ended)
      - lambda: |-
          id(my_tone_gen).trigger_click();
          id(my_tone_gen).stop_tone();
      - voice_assistant.stop:
      - light.turn_off: button_leds
      - globals.set:
          id: hook_down_timestamp
          value: !lambda 'return millis();'
      - globals.set:
          id: is_muted
          value: 'false'
      - script.stop: led_pulse_purple_mute
    on_release:
      # Hook Up (Call started)
      - if:
          condition:
            lambda: 'return (millis() - id(hook_down_timestamp)) < 500;'
          then:
            # Hook Flash detected
            - logger.log: "Hook Flash detected"
            - homeassistant.event:
                event: esphome.rotary_phone_flash
            # Local Feedback - Click and Restart Tone (Interrupt effect)
            - lambda: |-
                id(my_tone_gen).trigger_click();
                // Restart dial tone to simulate interruption
                id(my_tone_gen).start_tone(425.0);
          else:
            # Normal Pickup
            - if:
                condition:
                  media_player.is_playing: media_player_base
                then:
                  - media_player.stop: media_player_base
            
            # Start Dial Tone (Wait for user input)
            - lambda: 'id(my_tone_gen).start_tone(425.0);'

  # Speed Dial Buttons & Functions
  
  # Button 1: System Control
  - platform: gpio
    pin:
      number: ${pin_button_1}
      mode: INPUT_PULLUP
      inverted: true
    name: "Button 1 (System)"
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_click:
      - min_length: 50ms
        max_length: 500ms
        then:
          - switch.toggle: dnd_mode
          - if:
              condition:
                 switch.is_on: dnd_mode
              then:
                 - logger.log: "DND Enabled"
                 # Optional Red Flash?
              else:
                 - logger.log: "DND Disabled"
      - min_length: 2000ms
        max_length: 10000ms
        then:
          - light.turn_on:
               id: button_leds
               effect: "Battery Level"
          - delay: 3s
          - light.turn_off: button_leds

  # Button 2: Custom Action (HA)
  - platform: gpio
    pin:
      number: ${pin_button_2}
      mode: INPUT_PULLUP
      inverted: true
    name: "Button 2 (Action)"
    filters:
      - delayed_on: 15ms
      - delayed_off: 15ms
    on_press:
      - homeassistant.event:
           event: esphome.rotary_phone_button
           data:
             button: "2"

  # Button 3: Custom Action (HA)
  - platform: gpio
    pin:
      number: ${pin_button_3}
      mode: INPUT_PULLUP
      inverted: true
    name: "Button 3 (Action)"
    filters:
      - delayed_on: 15ms
      - delayed_off: 15ms
    on_press:
      - homeassistant.event:
           event: esphome.rotary_phone_button
           data:
             button: "3"

  # Button 4: Custom Action (Home Assistant)
  - platform: gpio
    pin:
      number: ${pin_button_4}
      mode: INPUT_PULLUP
      inverted: true
    name: "Button 4 (Action)"
    filters:
      - delayed_on: 15ms
      - delayed_off: 15ms
    # Sends binary_sensor event to HA automatically
    on_press:
      - homeassistant.event:
           event: esphome.rotary_phone_button
           data:
             button: "4"

  # Rotary Dial Active (Dial is rotating)
  - platform: gpio
    pin:
      number: ${pin_dial_active}
      mode: INPUT_PULLUP
      inverted: true
    name: "Rotary Dial Active"
    id: rotary_active
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      then:
        - lambda: 'id(my_tone_gen).stop_tone();'
        - globals.set:
            id: dial_pulse_count
            value: '0'
        - voice_assistant.stop:
        - logger.log: "Dialing started..."
    on_release:
      then:
        - logger.log: "Dialing finished."
        - script.execute: process_dialed_digit

  # Rotary Dial Pulse Counting
  - platform: gpio
    pin: 
      number: ${pin_dial_pulse}
      mode: INPUT_PULLUP
      inverted: true
    name: "Rotary Dial Pulse"
    id: rotary_pulse
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      then:
        # Acoustic tick (Electronic Click in Handset)
        - lambda: 'id(my_tone_gen).trigger_click();'
        - globals.set:
            id: dial_pulse_count
            value: !lambda 'return id(dial_pulse_count) + 1;'
