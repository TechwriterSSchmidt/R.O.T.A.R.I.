esphome:
  name: rotary-phone-agent
  friendly_name: Rotary Phone Agent
  min_version: 2024.7.0
  platformio_options:
    board_build.flash_mode: dio
    # LilyGO T7-S3 16MB Flash / 8MB PSRAM Specifics
    board_build.arduino.memory_type: qio_opi
    build_flags:
      - "-DBOARD_HAS_PSRAM"

esp32:
  board: esp32-s3-devkitc-1
  flash_size: 16MB
  partitions: default_16MB.csv
  framework:
    type: arduino

# Enable logging
logger:

# Enable debug component (Watchdog)
debug:

# Enable Home Assistant API
api:
  reboot_timeout: 5min
  services:
    - service: start_find_my_phone
      then:
        - script.execute: find_phone
    - service: stop_find_my_phone
      then:
        - script.stop: find_phone
        - light.turn_off: button_leds
    - service: start_broadcast_notification
      then:
        - script.execute: led_blink_yellow_broadcast
    - service: stop_broadcast_notification
      then:
        - script.stop: led_blink_yellow_broadcast
        - light.turn_off: button_leds

# Enable OTA updates
ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Reboot if no wifi connection for 5 minutes
  reboot_timeout: 5min

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Rotary-Phone-Agent Fallback"
    password: ""

captive_portal:

# Voice Assistant configuration
# Requires a microphone and speaker (e.g., I2S based like INMP441 and MAX98357A)
# Pinout angepasst für ESP32-S3

# I2S Bus A: Hörer (Mikrofon + Hörer-Lautsprecher)
i2s_audio:
  - id: i2s_bus_handset
    i2s_lrclk_pin: GPIO5
    i2s_bclk_pin: GPIO6

  # I2S Bus B: Sockel (Großer Lautsprecher für Klingeln/Musik)
  - id: i2s_bus_base
    i2s_lrclk_pin: GPIO16
    i2s_bclk_pin: GPIO18 # Geändert (war 17, Konflikt mit LED auf T7-S3)

microphone:
  - platform: i2s_audio
    id: mic_i2s
    i2s_audio_id: i2s_bus_handset
    i2s_din_pin: GPIO7
    adc_type: external
    pdm: false

speaker:
  # Lautsprecher im Hörer (für Sprachassistent)
  - platform: i2s_audio
    id: speaker_handset
    i2s_audio_id: i2s_bus_handset
    i2s_dout_pin: GPIO15
    dac_type: external

# Media Player für Klingeltöne & Musik (via I2S Sockel-Lautsprecher)
media_player:
  - platform: i2s_audio
    name: "Rotary Phone Base Speaker"
    id: media_player_base
    i2s_audio_id: i2s_bus_base
    i2s_dout_pin: GPIO19
    dac_type: external
    mode: mono
    on_play:
      - light.turn_on: button_leds
      - light.addressable_set:
          id: button_leds
          range_from: 0
          range_to: 4
          red: 0%
          green: 0%
          blue: 100% # Blau bei Musik/Klingeln
    on_idle:
      - light.turn_off: button_leds

voice_assistant:
  microphone: mic_i2s
  speaker: speaker_handset # Antwort nur im Hörer
  on_start:
    - if:
        condition:
          lambda: 'return id(is_muted);'
        then:
          - voice_assistant.stop:
          - logger.log: "Voice Assistant blocked because of Mute"
        else:
          - script.stop: led_blink_blue
          - script.stop: led_blink_red
          - light.turn_on: button_leds # Strip einschalten
          - light.addressable_set:
              id: button_leds
              range_from: 0
              range_to: 1
              red: 0%
              green: 100%
              blue: 0% # Grün = Zuhören
  on_stt_end:
    - script.execute: led_blink_blue # Blau blinken = Verarbeiten
  on_tts_start:
    - script.stop: led_blink_blue
    - light.addressable_set:
        id: button_leds
        range_from: 0
        range_to: 1
        red: 0%
        green: 0%
        blue: 0% # Aus während Antwort
  on_end:
    - script.stop: led_blink_blue
    - script.stop: led_blink_red
    - light.turn_off: button_leds
  on_error:
    - script.stop: led_blink_blue
    - script.execute: led_blink_red # Rot blinken = Fehler
    - delay: 2s
    - script.stop: led_blink_red
    - light.turn_off: button_leds

# Deep Sleep Configuration
# Optional: Aktivieren, um Strom zu sparen. Aufwachen durch Hörer (GPIO1), Tasten oder IMU.
# deep_sleep:
#   run_duration: 60s
#   sleep_duration: 10min
#   wakeup_pin:
#     number: GPIO1 # Hörer abnehmen weckt auf
#     inverted: true
#     mode: INPUT_PULLUP


# Button LEDs
light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: GPIO2 # Geändert für T7-S3 (externer Pin)
    num_leds: 4
    chipset: ws2812
    name: "Button LEDs"
    id: button_leds
    restore_mode: ALWAYS_OFF

# Hardware configuration

# Enable Bluetooth for Bermuda BLE Trilateration
esp32_ble_tracker:
  scan_parameters:
    interval: 1100ms
    window: 1100ms
    active: true

bluetooth_proxy:
  active: true

# I2C Bus für Sensoren (BME280, BNO055)
i2c:
  sda: GPIO8
  scl: GPIO9
  scan: true
  id: bus_a

# Haptic Motor Controller (DRV2605)
drv2605:
  i2c_id: bus_a
  id: haptic_motor
  vibrator_type: LRA
  library: TS2200_F # Optimierte Library für LRA (Library 6)

# UART für Audio (DY-SV17F)
uart:
  - id: uart_bus_dfplayer
    tx_pin: GPIO43
    rx_pin: GPIO44
    baud_rate: 9600

# OPTIONAL: UART für Radar (LD2410)
#  - id: uart_bus_radar
#    tx_pin: GPIO39 # ESP TX -> Radar RX
#    rx_pin: GPIO38 # ESP RX <- Radar TX
#    baud_rate: 256000
#    parity: NONE
#    stop_bits: 1

# DFPlayer wurde durch DY-SV17F (4MB Flash) ersetzt.
# Ansteuerung erfolgt nun direkt via UART Bytes.
# Dateisystem auf dem Flash:
# 00001.mp3 -> Klingelton
# 00002.mp3 -> Klick-Geräusch (Wählscheibe)
# 00003.mp3 -> Hook Flash Feedback / error

# OPTIONAL: Radar Sensor (LD2410)
# ld2410:
#   uart_id: uart_bus_radar

#  Sensors
sensor:
  # OPTIONAL: Environment Sensor (BME280)
#  - platform: bme280_i2c
#    i2c_id: bus_a
#    address: 0x76 # Prüfen: 0x76 oder 0x77
#    temperature:
#      name: "Phone Temperature"
#    humidity:
#      name: "Phone Humidity"
#    pressure:
#      name: "Phone Pressure"
#    update_interval: 60s

  # OPTIONAL: Radar Distances
#  - platform: ld2410
#    moving_distance:
#      name: "Moving Target Distance"
#    still_distance:
#      name: "Still Target Distance"
#    detection_distance:
#      name: "Detection Distance"

  # OPTIONAL: IMU & Shake-to-Wake (BNO055)
  # Connect BNO055 INT pin to a GPIO (e.g., GPIO3) for wakeup
#  - platform: bno055
#    i2c_id: bus_a
#    address: 0x28
#    accel_x:
#      name: "IMU Accel X"
#    accel_y:
#      name: "IMU Accel Y"
#    accel_z:
#      name: "IMU Accel Z"
#    update_interval: 5s

  - platform: adc
    pin: GPIO4 # GPIO4 ist ADC1_CH3.
    name: "Battery Voltage"
    id: battery_voltage
    update_interval: 60s
    attenuation: 12db
    filters:
      - multiply: 2.0 # Spannungsteiler anpassen falls nötig
    on_value:
      then:
        - if:
            condition:
              lambda: |-
                // Umrechnung Prozent -> Volt für den Vergleich (Linear: 3.0V=0%, 4.2V=100%)
                float threshold_volts = 3.0 + (id(low_battery_threshold).state / 100.0) * 1.2;
                return x < threshold_volts;
            then:
              - if:
                  condition:
                    not:
                      script.is_running: led_pulse_red_battery
                  then:
                    - script.execute: led_pulse_red_battery
                    - homeassistant.event:
                        event: esphome.rotary_phone_low_battery
                    - logger.log: "Battery Low! Starting alarm."
            else:
              - if:
                  condition:
                    script.is_running: led_pulse_red_battery
                  then:
                    - script.stop: led_pulse_red_battery
                    - light.addressable_set:
                        id: button_leds
                        range_from: 3
                        range_to: 4
                        red: 0%
                        green: 0%
                        blue: 0%
                    - logger.log: "Battery OK. Stopping alarm."

  - platform: template
    name: "Battery Level"
    id: battery_level
    unit_of_measurement: "%"
    device_class: battery
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(battery_voltage).state)) return NAN;
      // Linear mapping: 3.0V -> 0%, 4.2V -> 100%
      float level = (id(battery_voltage).state - 3.0) / 1.2 * 100.0;
      if (level < 0) return 0;
      if (level > 100) return 100;
      return level;
    update_interval: 60s

  - platform: template
    name: "Last Dialed Digit"
    id: last_dialed_digit
    icon: "mdi:dialpad"
    accuracy_decimals: 0
    force_update: true

# Globale Variablen
globals:
  - id: dial_pulse_count
    type: int
    initial_value: '0'
  - id: hook_down_timestamp
    type: int
    initial_value: '0'
  - id: multi_digit_mode
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: dialed_number_buffer
    type: std::string
    restore_value: no
    initial_value: '""'
  - id: dial_string_timeout_ms
    type: int
    restore_value: yes
    initial_value: '3000'
  - id: is_muted
    type: bool
    restore_value: no
    initial_value: 'false'

number:
  - platform: template
    name: "Low Battery Threshold"
    id: low_battery_threshold
    unit_of_measurement: "%"
    min_value: 5
    max_value: 50
    step: 1
    initial_value: 20
    optimistic: true
    restore_value: true

  - platform: template
    name: "Rotary Phone String Timeout"
    id: rotary_phone_string_timeout
    unit_of_measurement: "ms"
    min_value: 500
    max_value: 10000
    step: 100
    lambda: 'return id(dial_string_timeout_ms);'
    set_action:
      - globals.set:
          id: dial_string_timeout_ms
          value: !lambda 'return x;'

  - platform: template
    name: "Phone Volume"
    id: phone_volume
    icon: "mdi:volume-high"
    min_value: 0
    max_value: 30
    step: 1
    initial_value: 20
    optimistic: true
    restore_value: true
    set_action:
      - lambda: |-
          uint8_t vol = (uint8_t)x;
          uint8_t cmd[] = {0xAA, 0x13, 0x01, vol};
          uint8_t sum = 0;
          for(int i=0; i<4; i++) sum += cmd[i];
          id(uart_bus_dfplayer).write_array(cmd, 4);
          id(uart_bus_dfplayer).write_byte(sum);

  - platform: template
    name: "Ringtone Count"
    id: ring_count
    min_value: 1
    max_value: 20
    step: 1
    initial_value: 5
    optimistic: true
    restore_value: true

  - platform: template
    name: "Ringtone Duration"
    id: ring_duration
    unit_of_measurement: "ms"
    min_value: 1000
    max_value: 10000
    step: 100
    initial_value: 3000
    optimistic: true
    restore_value: true

  - platform: template
    name: "Ringtone Pause"
    id: ring_pause
    unit_of_measurement: "ms"
    min_value: 500
    max_value: 10000
    step: 100
    initial_value: 2000
    optimistic: true
    restore_value: true

switch:
  - platform: template
    name: "Haptic Ringing"
    id: haptic_ringing
    icon: "mdi:vibrate"
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true

  - platform: template
    name: "Rotary Phone Multi-Digit Mode"
    id: rotary_phone_multi_digit_mode
    optimistic: true
    turn_on_action:
      - globals.set:
          id: multi_digit_mode
          value: 'true'
    turn_off_action:
      - globals.set:
          id: multi_digit_mode
          value: 'false'
      - script.execute: flush_dialed_number


button:
  - platform: restart
    id: sys_restart
    name: "System Restart"

# Skripte
script:
  # Hilfsskript für DY-SV17F Modul (Play by File Number)
  # Befehl: AA 07 02 High Low SM
  # SM = Summe(AA+07+02+High+Low) & 0xFF
  # Datasheet: https://raw.githubusercontent.com/tasmota/docs/master/docs/_media/DY-SV17F_datasheet.pdf
  # Docs Collection: https://github.com/smoluks/DY-SV17F (UART Mode Guide, etc.)
  # UART Guide: https://arduino.ua/files/UART%20mode%20user_s%20guide.pdf
  - id: play_mp3
    parameters:
      file_num: int
    then:
      - lambda: |-
          uint8_t high = (file_num >> 8) & 0xFF;
          uint8_t low = file_num & 0xFF;
          uint8_t cmd[] = {0xAA, 0x07, 0x02, high, low};
          uint8_t sum = 0;
          for(int i=0; i<5; i++) sum += cmd[i];
          id(uart_bus_dfplayer).write_array(cmd, 5);
          id(uart_bus_dfplayer).write_byte(sum);

  # Hilfsskript Stop
  - id: stop_mp3
    then:
      - uart.write: 
          id: uart_bus_dfplayer
          data: [0xAA, 0x04, 0x00, 0xAE]

  # Skript zum Verarbeiten der gewählten Ziffer
  - id: flush_dialed_number
    then:
      - if:
          condition:
            lambda: 'return id(dialed_number_buffer).length() > 0;'
          then:
            # Magic Codes (Multi-Digit Mode)
            - if:
                condition:
                   lambda: 'return id(dialed_number_buffer) == "999";'
                then:
                   - logger.log: "Magic Code 999: System Reboot"
                   - button.press: sys_restart
                else:
                   - homeassistant.event:
                       event: esphome.rotary_phone_dial_string
                       data_template:
                         number: !lambda 'return id(dialed_number_buffer);'
                   - logger.log: 
                       format: "Dialed String sent: %s"
                       args: [ 'id(dialed_number_buffer).c_str()' ]
            - globals.set:
                id: dialed_number_buffer
                value: '""'

  - id: flush_dialed_number_timer
    mode: restart
    then:
      - delay: !lambda 'return id(dial_string_timeout_ms);'
      - script.execute: flush_dialed_number

  - id: led_blink_blue
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return true;'
          then:
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 1
                red: 0%
                green: 0%
                blue: 100%
            - delay: 500ms
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 1
                red: 0%
                green: 0%
                blue: 0%
            - delay: 500ms

  - id: led_blink_red
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return true;'
          then:
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 1
                red: 100%
                green: 0%
                blue: 0%
            - delay: 300ms
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 1
                red: 0%
                green: 0%
                blue: 0%
            - delay: 300ms

  # Skript: Broadcast Notification (4. LED blinkt Gelb)
  - id: led_blink_yellow_broadcast
    mode: restart
    then:
      - light.turn_on: button_leds
      - while:
          condition:
            lambda: 'return true;'
          then:
            - light.addressable_set:
                id: button_leds
                range_from: 3
                range_to: 4
                red: 100%
                green: 100%
                blue: 0% # Gelb
            - delay: 500ms
            - light.addressable_set:
                id: button_leds
                range_from: 3
                range_to: 4
                red: 0%
                green: 0%
                blue: 0%
            - delay: 500ms

  # Skript: Find My Phone (Alarm)
  - id: find_phone
    mode: restart
    then:
      - light.turn_on: button_leds
      - while:
          condition:
            lambda: 'return true;'
          then:
            # Visueller Alarm (Alle LEDs Rot blinken)
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 4
                red: 100%
                green: 0%
                blue: 0%
            # Akustischer Alarm (Piepen über Sockel-Lautsprecher simulieren oder MP3)
            # Hier nutzen wir einfach den Media Player, falls eine URL übergeben wird,
            # oder wir verlassen uns auf das Blinken.
            - delay: 200ms
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 4
                red: 0%
                green: 0%
                blue: 0%
            - delay: 200ms

  - id: process_dialed_digit
    mode: restart
    then:
      - logger.log:
          format: "Wählscheibe: %d Impulse gezählt"
          args: [ 'id(dial_pulse_count)' ]
      
      # Update sensor with the last dialed digit
      - sensor.template.publish:
          id: last_dialed_digit
          state: !lambda 'return (id(dial_pulse_count) == 10) ? 0 : id(dial_pulse_count);'

      - if:
          condition:
            lambda: 'return id(dial_pulse_count) > 0;'
          then:
            - if:
                condition:
                  lambda: 'return id(dial_pulse_count) > 20;'
                then:
                  - logger.log: "Ghost pulse detected (Count > 20), ignoring."
                else:
                  - if:
                      condition:
                        lambda: 'return id(multi_digit_mode);'
                      then:
                        # MULTI-DIGIT MODE
                        - lambda: |-
                            int digit = (id(dial_pulse_count) == 10) ? 0 : id(dial_pulse_count);
                            id(dialed_number_buffer) += std::to_string(digit);
                            ESP_LOGD("dial", "Digit added. Buffer: %s", id(dialed_number_buffer).c_str());
                        - script.stop: flush_dialed_number_timer
                        - script.execute: flush_dialed_number_timer
                      else:
                        # SINGLE DIGIT MODE (Standard)
                        # Magic Code: 0 -> Start Voice Assistant Manual
                        - if:
                            condition:
                              lambda: 'return (id(dial_pulse_count) == 10);'
                            then:
                              - logger.log: "Magic Code 0: Starting Voice Assistant"
                              - voice_assistant.start:
                            else:
                              - homeassistant.event:
                                  event: esphome.rotary_phone_dial
                                  data_template:
                                    digit: !lambda 'return (id(dial_pulse_count) == 10) ? 0 : id(dial_pulse_count);'
      
      # Zähler zurücksetzen
      - globals.set:
          id: dial_pulse_count
          value: '0'

  # Skript: Telefon klingeln lassen
  - id: ring_phone
    mode: restart
    then:
      - repeat:
          count: !lambda 'return id(ring_count).state;'
          then:
            # Nur klingeln, wenn Hörer aufgelegt ist (Sensor ist ON)
            - if:
                condition:
                  binary_sensor.is_on: phone_hook
                then:
                  # Audio abspielen (wenn Volume > 0)
                  - if:
                      condition:
                         lambda: 'return id(phone_volume).state > 0;'
                      then:
                        - script.execute:
                            id: play_mp3
                            file_num: 1 # 00001.mp3
                  
                  # Vibration Motor (über Transistor)
                  - if:
                      condition:
                        switch.is_on: haptic_ringing
                      then:
                        - repeat:
                            count: 15 # Anzahl der Vibrationen pro "Ring"
                            then:
                              - drv2605.set_waveform:
                                  id: haptic_motor
                                  effect: 1 # Strong Click
                              - drv2605.go: haptic_motor
                              - delay: 50ms

                  # Wartezeit = Länge des Klingeltons + Pause
                  # (Achtung: Die Haptic-Loop oben blockiert delayfrei, 
                  #  aber wir haben delay:50ms * 15 = 750ms "verbraucht")
                  - delay: !lambda 'return (id(ring_duration).state - 750 < 0) ? 0 : (id(ring_duration).state - 750);'
                  - delay: !lambda 'return id(ring_pause).state;'
                else:
                  - script.stop: ring_phone

  - id: led_pulse_red_battery
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return true;'
          then:
            # Einblenden (Rot, LED 4)
            - light.addressable_set:
                id: button_leds
                range_from: 3
                range_to: 4
                red: 100%
                green: 0%
                blue: 0%
            - delay: 1000ms
            # Ausblenden
            - light.addressable_set:
                id: button_leds
                range_from: 3
                range_to: 4
                red: 10%
                green: 0%
                blue: 0%
            - delay: 1000ms

  - id: led_pulse_purple_mute
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return id(is_muted);'
          then:
            # Einblenden (Lila)
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 1 # Nur LED 1
                red: 50%
                green: 0%
                blue: 50%
            - delay: 1000ms
            # Ausblenden
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 1
                red: 10%
                green: 0%
                blue: 10%
            - delay: 1000ms

# Binary sensors configuration
binary_sensor:
  # Hook switch (Telefonhörer aufgelegt)
  # Wenn der Hörer aufgelegt ist, wird der Taster gedrückt (Low oder High je nach Verdrahtung)
  - platform: gpio
    pin:
      number: GPIO1
      mode: INPUT_PULLUP
      inverted: true # Anpassen, falls Logik umgekehrt ist
    name: "Phone Hook"
    id: phone_hook
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      # Hörer aufgelegt -> Stop & Timestamp speichern & Mute Reset
      - voice_assistant.stop:
      - light.turn_off: button_leds
      - globals.set:
          id: hook_down_timestamp
          value: !lambda 'return millis();'
      # Reset Mute State
      - globals.set:
          id: is_muted
          value: 'false'
      - script.stop: led_pulse_purple_mute
    on_release:
      # Hörer abgenommen -> Prüfen ob Flash oder echtes Abnehmen
      - if:
          condition:
            lambda: 'return (millis() - id(hook_down_timestamp)) < 500;'
          then:
            # Hook Flash (kurz getippt) -> Event senden
            - logger.log: "Hook Flash detected"
            - homeassistant.event:
                event: esphome.rotary_phone_flash
            # Lokales Feedback (Doppel-Piep)
            - script.execute:
                id: play_mp3
                file_num: 3 # 00003.mp3
          else:
            # Normales Abnehmen -> Stop Media & Start Listening
            - if:
                condition:
                  media_player.is_playing: media_player_base
                then:
                  - media_player.stop: media_player_base
            - voice_assistant.start:

  # Speed dial buttons (Schnellwahltaster)
  # Taste 1 (Mute Funktion bei Long Press)
  - platform: gpio
    pin:
      number: GPIO10
      mode: INPUT_PULLUP
    name: "Speed Dial 1"
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_click:
      - min_length: 50ms
        max_length: 1000ms
        then:
          - homeassistant.event:
              event: esphome.rotary_phone_button
              data:
                button: "1"
      - min_length: 3000ms
        max_length: 10000ms
        then:
          - if:
              condition:
                lambda: 'return id(is_muted);'
              then:
                # Unmute
                - globals.set:
                    id: is_muted
                    value: 'false'
                - voice_assistant.start: # Mikrofon wieder aktivieren (falls gewünscht)
                - script.stop: led_pulse_purple_mute
                - light.turn_off: button_leds
                - logger.log: "Microphone Unmuted"
              else:
                # Mute
                - globals.set:
                    id: is_muted
                    value: 'true'
                - voice_assistant.stop:
                - script.execute: led_pulse_purple_mute
                - logger.log: "Microphone Muted"

  # Taste 2
  - platform: gpio
    pin:
      number: GPIO11
      mode: INPUT_PULLUP
    name: "Speed Dial 2"
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      - homeassistant.event:
          event: esphome.rotary_phone_button
          data:
            button: "2"
  
  # Taste 3
  - platform: gpio
    pin:
      number: GPIO12
      mode: INPUT_PULLUP
    name: "Speed Dial 3"
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      - homeassistant.event:
          event: esphome.rotary_phone_button
          data:
            button: "3"
  
  # Rotary Dial Active (Wählscheibe dreht sich)
  # Ersetzt Speed Dial 4 (GPIO13)
  # Ruhe = 0, Aktiv = 1
  - platform: gpio
    pin:
      number: GPIO13
      mode: INPUT_PULLUP
      inverted: true
    name: "Rotary Dial Active"
    id: rotary_active
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      then:
        # Start des Wählvorgangs -> Zähler reset
        - globals.set:
            id: dial_pulse_count
            value: '0'
        # Assistenten/Musik stoppen, damit man in Ruhe wählen kann
        - voice_assistant.stop:
        # Freizeichen stoppen (falls wir eines implementieren)
        # - dfplayer.stop
        - logger.log: "Dialing started..."
    on_release:
      then:
        # Ende des Wählvorgangs (Ziffer fertig) -> Verarbeiten
        - logger.log: "Dialing finished."
        - script.execute: process_dialed_digit

  # Rotary Dial (Wählscheibe) - Impuls-Pin
  # Wir nutzen binary_sensor statt pulse_counter für bessere Kontrolle und Entprellung
  - platform: gpio
    pin: 
      number: GPIO14
      mode: INPUT_PULLUP
      inverted: true
    name: "Rotary Dial Pulse"
    id: rotary_pulse
    filters:
      # Entprellung: Signal muss stabil sein (Werte anpassen je nach Alter der Scheibe)
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      then:
        # Akustisches Feedback (Klick) lokal
        - script.execute:
            id: play_mp3
            file_num: 2 # 00002.mp3
        # Zähler erhöhen
        - globals.set:
            id: dial_pulse_count
            value: !lambda 'return id(dial_pulse_count) + 1;'
        # Timer (process_dialed_digit) wird hier NICHT mehr gestartet, 
        # das übernimmt jetzt der Rotary Dial Active Sensor (GPIO13 Release)

# End of file
