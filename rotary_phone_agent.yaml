esphome:
  name: rotary-phone-agent
  friendly_name: Rotary Phone Agent
  min_version: 2024.7.0
  platformio_options:
    board_build.flash_mode: dio

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  services:
    - service: start_find_my_phone
      then:
        - script.execute: find_phone
    - service: stop_find_my_phone
      then:
        - script.stop: find_phone
        - light.turn_off: button_leds
    - service: start_broadcast_notification
      then:
        - script.execute: led_blink_yellow_broadcast
    - service: stop_broadcast_notification
      then:
        - script.stop: led_blink_yellow_broadcast
        - light.turn_off: button_leds

# Enable OTA updates
ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Rotary-Phone-Agent Fallback"
    password: ""

captive_portal:

# Voice Assistant configuration
# Requires a microphone and speaker (e.g., I2S based like INMP441 and MAX98357A)
# Pinout angepasst für ESP32-S3

# I2S Bus A: Hörer (Mikrofon + Hörer-Lautsprecher)
i2s_audio:
  - id: i2s_bus_handset
    i2s_lrclk_pin: GPIO5
    i2s_bclk_pin: GPIO6

  # I2S Bus B: Sockel (Großer Lautsprecher für Klingeln/Musik)
  - id: i2s_bus_base
    i2s_lrclk_pin: GPIO16
    i2s_bclk_pin: GPIO18 # Geändert (war 17, Konflikt mit LED auf T7-S3)

microphone:
  - platform: i2s_audio
    id: mic_i2s
    i2s_audio_id: i2s_bus_handset
    i2s_din_pin: GPIO7
    adc_type: external
    pdm: false

speaker:
  # Lautsprecher im Hörer (für Sprachassistent)
  - platform: i2s_audio
    id: speaker_handset
    i2s_audio_id: i2s_bus_handset
    i2s_dout_pin: GPIO15
    dac_type: external

# Media Player für Klingeltöne & Musik (via I2S Sockel-Lautsprecher)
media_player:
  - platform: i2s_audio
    name: "Rotary Phone Base Speaker"
    id: media_player_base
    i2s_audio_id: i2s_bus_base
    i2s_dout_pin: GPIO19
    dac_type: external
    mode: mono
    on_play:
      - light.turn_on: button_leds
      - light.addressable_set:
          id: button_leds
          range_from: 0
          range_to: 4
          red: 0%
          green: 0%
          blue: 100% # Blau bei Musik/Klingeln
    on_idle:
      - light.turn_off: button_leds

voice_assistant:
  microphone: mic_i2s
  speaker: speaker_handset # Antwort nur im Hörer
  on_start:
    - script.stop: led_blink_blue
    - script.stop: led_blink_red
    - light.turn_on: button_leds # Strip einschalten
    - light.addressable_set:
        id: button_leds
        range_from: 0
        range_to: 1
        red: 0%
        green: 100%
        blue: 0% # Grün = Zuhören
  on_stt_end:
    - script.execute: led_blink_blue # Blau blinken = Verarbeiten
  on_tts_start:
    - script.stop: led_blink_blue
    - light.addressable_set:
        id: button_leds
        range_from: 0
        range_to: 1
        red: 0%
        green: 0%
        blue: 0% # Aus während Antwort
  on_end:
    - script.stop: led_blink_blue
    - script.stop: led_blink_red
    - light.turn_off: button_leds
  on_error:
    - script.stop: led_blink_blue
    - script.execute: led_blink_red # Rot blinken = Fehler
    - delay: 2s
    - script.stop: led_blink_red
    - light.turn_off: button_leds

# Button LEDs
light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: GPIO2 # Geändert für T7-S3 (externer Pin)
    num_leds: 4
    chipset: ws2812
    name: "Button LEDs"
    id: button_leds
    restore_mode: ALWAYS_OFF

# Hardware configuration

# Enable Bluetooth for Bermuda BLE Trilateration
esp32_ble_tracker:
  scan_parameters:
    interval: 1100ms
    window: 1100ms
    active: true

bluetooth_proxy:
  active: true

# Piezo Buzzer für lokales Feedback (Klicken/Piepen)
output:
  - platform: ledc
    id: buzzer_pwm
    pin: GPIO21 # Geändert: GPIO4 wird für Batterie-Messung benötigt.

rtttl:
  output: buzzer_pwm
  id: buzzer



# Battery Sensor
sensor:
  - platform: adc
    pin: GPIO4 # Geändert: GPIO35 ist beim S3 kein ADC oder belegt. GPIO4 ist ADC1_CH3.
    name: "Battery Voltage"
    update_interval: 60s
    attenuation: 12db
    filters:
      - multiply: 2.0 # Spannungsteiler anpassen falls nötig
    on_value_range:
      - below: 3.3
        then:
          - homeassistant.event:
              event: esphome.rotary_phone_low_battery
          - logger.log: "Battery Low! Sending event."

# Globale Variablen
globals:
  - id: dial_pulse_count
    type: int
    initial_value: '0'
  - id: hook_down_timestamp
    type: int
    initial_value: '0'
  - id: multi_digit_mode
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: dialed_number_buffer
    type: std::string
    restore_value: no
    initial_value: '""'
  - id: dial_timeout_ms
    type: int
    restore_value: yes
    initial_value: '3000'

number:
  - platform: template
    name: "Rotary Phone Dial Timeout"
    id: rotary_phone_dial_timeout
    unit_of_measurement: "ms"
    min_value: 500
    max_value: 10000
    step: 100
    lambda: 'return id(dial_timeout_ms);'
    set_action:
      - globals.set:
          id: dial_timeout_ms
          value: !lambda 'return x;'

switch:
  - platform: template
    name: "Rotary Phone Multi-Digit Mode"
    id: rotary_phone_multi_digit_mode
    optimistic: true
    turn_on_action:
      - globals.set:
          id: multi_digit_mode
          value: 'true'
    turn_off_action:
      - globals.set:
          id: multi_digit_mode
          value: 'false'
      - script.execute: flush_dialed_number

# Rtttl entfernt, da Feedback über Hörer


# Skript zum Verarbeiten der gewählten Ziffer
script:
  - id: flush_dialed_number
    then:
      - if:
          condition:
            lambda: 'return id(dialed_number_buffer).length() > 0;'
          then:
            - homeassistant.event:
                event: esphome.rotary_phone_dial_string
                data_template:
                  number: !lambda 'return id(dialed_number_buffer);'
            - logger.log: 
                format: "Dialed String sent: %s"
                args: [ 'id(dialed_number_buffer).c_str()' ]
            - globals.set:
                id: dialed_number_buffer
                value: '""'

  - id: flush_dialed_number_timer
    mode: restart
    then:
      - delay: !lambda 'return id(dial_timeout_ms);'
      - script.execute: flush_dialed_number

  - id: led_blink_blue
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return true;'
          then:
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 1
                red: 0%
                green: 0%
                blue: 100%
            - delay: 500ms
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 1
                red: 0%
                green: 0%
                blue: 0%
            - delay: 500ms

  - id: led_blink_red
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return true;'
          then:
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 1
                red: 100%
                green: 0%
                blue: 0%
            - delay: 300ms
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 1
                red: 0%
                green: 0%
                blue: 0%
            - delay: 300ms

  # Skript: Broadcast Notification (4. LED blinkt Gelb)
  - id: led_blink_yellow_broadcast
    mode: restart
    then:
      - light.turn_on: button_leds
      - while:
          condition:
            lambda: 'return true;'
          then:
            - light.addressable_set:
                id: button_leds
                range_from: 3
                range_to: 4
                red: 100%
                green: 100%
                blue: 0% # Gelb
            - delay: 500ms
            - light.addressable_set:
                id: button_leds
                range_from: 3
                range_to: 4
                red: 0%
                green: 0%
                blue: 0%
            - delay: 500ms

  # Skript: Find My Phone (Alarm)
  - id: find_phone
    mode: restart
    then:
      - light.turn_on: button_leds
      - while:
          condition:
            lambda: 'return true;'
          then:
            # Visueller Alarm (Alle LEDs Rot blinken)
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 4
                red: 100%
                green: 0%
                blue: 0%
            # Akustischer Alarm (Piepen über Sockel-Lautsprecher simulieren oder MP3)
            # Hier nutzen wir einfach den Media Player, falls eine URL übergeben wird,
            # oder wir verlassen uns auf das Blinken.
            - delay: 200ms
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 4
                red: 0%
                green: 0%
                blue: 0%
            - delay: 200ms

  - id: process_dialed_digit
    mode: restart
    then:
      # Wartezeit (Inter-Digit Timeout)
      - delay: 600ms
      - logger.log:
          format: "Wählscheibe: %d Impulse gezählt"
          args: [ 'id(dial_pulse_count)' ]
      
      # Logik-Weiche: Musiksteuerung vs. Home Assistant Event
      - if:
          condition:
            # Prüfen, ob der Sockel-Lautsprecher gerade spielt
            media_player.is_playing: media_player_base
          then:
            # MODUS: LAUTSTÄRKE REGELN
            - logger.log: "Musik läuft - Ändere Lautstärke"
            - media_player.volume_set:
                id: media_player_base
                # 1 Impuls = 10%, 5 = 50%, 10 (0) = 100%
                volume: !lambda 'return (id(dial_pulse_count) * 0.1);'
            # Kurzes visuelles Feedback (Blau aufblitzen)
            - light.turn_on: button_leds
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 4
                red: 0%
                green: 0%
                blue: 100%
            - delay: 200ms
            - light.turn_off: button_leds
          
          else:
            # MODUS: STANDARD EVENT
            - if:
                condition:
                  lambda: 'return id(dial_pulse_count) > 0;'
                then:
                  - if:
                      condition:
                        lambda: 'return id(multi_digit_mode);'
                      then:
                        # MULTI-DIGIT MODE
                        - lambda: |-
                            int digit = (id(dial_pulse_count) == 10) ? 0 : id(dial_pulse_count);
                            id(dialed_number_buffer) += std::to_string(digit);
                            ESP_LOGD("dial", "Digit added. Buffer: %s", id(dialed_number_buffer).c_str());
                        - script.stop: flush_dialed_number_timer
                        - script.execute: flush_dialed_number_timer
                      else:
                        # SINGLE DIGIT MODE (Original behavior)
                        - homeassistant.event:
                            event: esphome.rotary_phone_dial
                            data_template:
                              digit: !lambda 'return (id(dial_pulse_count) == 10) ? 0 : id(dial_pulse_count);'
      
      # Zähler zurücksetzen
      - globals.set:
          id: dial_pulse_count
          value: '0'

binary_sensor:
  # Hook switch (Telefonhörer aufgelegt)
  # Wenn der Hörer aufgelegt ist, wird der Taster gedrückt (Low oder High je nach Verdrahtung)
  - platform: gpio
    pin:
      number: GPIO1
      mode: INPUT_PULLUP
      inverted: true # Anpassen, falls Logik umgekehrt ist
    name: "Phone Hook"
    id: phone_hook
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      # Hörer aufgelegt -> Stop & Timestamp speichern
      - voice_assistant.stop:
      - light.turn_off: button_leds
      - globals.set:
          id: hook_down_timestamp
          value: !lambda 'return millis();'
    on_release:
      # Hörer abgenommen -> Prüfen ob Flash oder echtes Abnehmen
      - if:
          condition:
            lambda: 'return (millis() - id(hook_down_timestamp)) < 500;'
          then:
            # Hook Flash (kurz getippt) -> Event senden
            - logger.log: "Hook Flash detected"
            - homeassistant.event:
                event: esphome.rotary_phone_flash
            # Lokales Feedback (Doppel-Piep)
            - rtttl.play: "two_beeps:d=16,o=5,b=100:c,p,c"
          else:
            # Normales Abnehmen -> Stop Media & Start Listening
            - if:
                condition:
                  media_player.is_playing: media_player_base
                then:
                  - media_player.stop: media_player_base
            - voice_assistant.start:

  # Speed dial buttons (Schnellwahltaster)
  # Taste 1
  - platform: gpio
    pin:
      number: GPIO10
      mode: INPUT_PULLUP
    name: "Speed Dial 1"
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      - homeassistant.event:
          event: esphome.rotary_phone_button
          data:
            button: "1"

  # Taste 2
  - platform: gpio
    pin:
      number: GPIO11
      mode: INPUT_PULLUP
    name: "Speed Dial 2"
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      - homeassistant.event:
          event: esphome.rotary_phone_button
          data:
            button: "2"
  
  # Taste 3
  - platform: gpio
    pin:
      number: GPIO12
      mode: INPUT_PULLUP
    name: "Speed Dial 3"
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      - homeassistant.event:
          event: esphome.rotary_phone_button
          data:
            button: "3"
  
  # Taste 4
  - platform: gpio
    pin:
      number: GPIO13
      mode: INPUT_PULLUP
    name: "Speed Dial 4"
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      - homeassistant.event:
          event: esphome.rotary_phone_button
          data:
            button: "4"

  # Rotary Dial (Wählscheibe) - Impuls-Pin
  # Wir nutzen binary_sensor statt pulse_counter für bessere Kontrolle und Entprellung
  - platform: gpio
    pin: 
      number: GPIO14
      mode: INPUT_PULLUP
    name: "Rotary Dial Pulse"
    id: rotary_pulse
    filters:
      # Entprellung: Signal muss stabil sein (Werte anpassen je nach Alter der Scheibe)
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      then:
        # Akustisches Feedback (Klick) lokal via Piezo
        - rtttl.play: "click:d=32,o=6,b=100:c"
        # Zähler erhöhen
        - globals.set:
            id: dial_pulse_count
            value: !lambda 'return id(dial_pulse_count) + 1;'
        # Timer neu starten (wartet auf Ende der Impulsfolge)
        - script.execute: process_dialed_digit
