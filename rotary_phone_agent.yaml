esphome:
  name: rotary-phone-agent
  friendly_name: "R.O.T.A.R.I."
  min_version: 2024.7.0
  includes:
    - src/rotary_helpers.h
    - components/mux_speaker/mux_speaker.h
  platformio_options:
    board_build.flash_mode: dio
    # Generic ESP32-S3 16MB Flash / 8MB PSRAM Specifics
    board_build.arduino.memory_type: qio_opi
    build_flags:
      - "-DBOARD_HAS_PSRAM"
      - "-DARDUINO_USB_CDC_ON_BOOT=1"

# Hardware Pin Definitions
# Change these values here to adapt to different board revisions
substitutions:
  # I2S Audio - Handset (Microphone & Ear Speaker)
  pin_i2s_handset_lrclk: GPIO5
  pin_i2s_handset_bclk: GPIO6
  pin_i2s_handset_din: GPIO7   # Mic Data In
  pin_i2s_handset_dout: GPIO15 # Speaker Data Out

  # I2S Audio - Base (Main Speaker for Ringtone/Music)
  pin_i2s_base_lrclk: GPIO16
  pin_i2s_base_bclk: GPIO18
  pin_i2s_base_dout: GPIO19

  # Peripherals
  pin_led_strip: GPIO2
  pin_battery_voltage: GPIO4
  
  # I2C Bus
  pin_i2c_sda: GPIO8
  pin_i2c_scl: GPIO9

  # Rotary Phone Mechanism
  pin_hook_switch: GPIO1      # Detects if handset is on hook
  pin_dial_pulse: GPIO14      # Dial pulse counting
  pin_dial_active: GPIO13     # Active while dial is rotating
  
  # Speed Dial Buttons
  pin_button_1: GPIO10
  pin_button_2: GPIO11
  pin_button_3: GPIO12
  pin_button_4: GPIO21 # Adjust if necessary

# External Components
external_components:
  - source:
      type: local
      path: components
    components: [ drv2605, vintage_tone_generator, mux_speaker ]

esp32:
  board: esp32-s3-devkitc-1
  flash_size: 16MB
  partitions: default_16MB.csv
  framework:
    type: arduino

# Enable logging (default 115200)
logger:
  hardware_uart: USB_CDC
  level: DEBUG



# Enable debug component
debug:

# Enable Home Assistant API
api:
  reboot_timeout: 5min
  services:
    - service: start_find_my_phone
      then:
        - script.execute: find_phone
    - service: stop_find_my_phone
      then:
        - script.stop: find_phone
        - light.turn_off: button_leds
    - service: start_broadcast_notification
      then:
        - light.turn_on:
            id: button_leds
            effect: "Broadcast Pulse"
    - service: stop_broadcast_notification
      then:
        - light.turn_off: button_leds
    - service: start_listening
      then:
        - voice_assistant.start

# Enable OTA updates
ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  reboot_timeout: 5min

  # Captive Portal Fallback
  ap:
    ssid: "Rotary-Phone-Agent Fallback"
    password: "" # Consider moving this to secrets if security is a concern

captive_portal:

# Voice Assistant configuration
# Requires a microphone and speaker (e.g., I2S based like INMP441 and MAX98357A)

# I2S Bus A: Handset
i2s_audio:
  - id: i2s_bus_handset
    i2s_lrclk_pin: ${pin_i2s_handset_lrclk}
    i2s_bclk_pin: ${pin_i2s_handset_bclk}

  # I2S Bus B: Base Speaker
  - id: i2s_bus_base
    i2s_lrclk_pin: ${pin_i2s_base_lrclk}
    i2s_bclk_pin: ${pin_i2s_base_bclk}

microphone:
  - platform: i2s_audio
    id: mic_i2s
    i2s_audio_id: i2s_bus_handset
    i2s_din_pin: ${pin_i2s_handset_din}
    adc_type: external
    pdm: false

vintage_tone_generator:
  id: my_tone_gen
  i2s_audio_id: i2s_bus_handset

speaker:
  # Handset Speaker (Standard for Voice Assistant)
  #- platform: i2s_audio
  #  id: speaker_handset
  #  i2s_audio_id: i2s_bus_handset
  #  i2s_dout_pin: ${pin_i2s_handset_dout}
  #  dac_type: external
  
  # Smart Mux Speaker (Routing based on Mode)
  - platform: mux_speaker
    id: speaker_handset # Keeping ID for compatibility
    handset_bus: i2s_bus_handset
    base_bus: i2s_bus_base
    mode_switch: speaker_mode
    # Note: Standard I2S pins are defined in i2s_audio components,
    # and this virtual speaker routes writes to them.
    # We must ensure the actual I2S buses are initialized.



# Media Player for Ringtones & Music (Base Speaker)
media_player:
  - platform: i2s_audio
    name: "Rotary Phone Base Speaker"
    id: media_player_base
    i2s_audio_id: i2s_bus_base
    i2s_dout_pin: ${pin_i2s_base_dout}
    dac_type: external
    mode: mono
    on_play:
      - light.turn_on: button_leds
      - light.addressable_set:
          id: button_leds
          range_from: 0
          range_to: 1
          red: 0%
          green: 0%
          blue: 100% # Blue for Music/Ringing
    on_idle:
      - light.turn_off: button_leds

voice_assistant:
  microphone: mic_i2s
  auto_gain: 0dBFS
  speaker: speaker_handset # Respond only via Handset
  on_start:
    - if:
        condition:
          switch.is_on: mic_mute
        then:
          - voice_assistant.stop:
          - logger.log: "Voice Assistant blocked because of Mute"
          - light.turn_on:
              id: button_leds
              effect: "Mute Pulse"
        else:
          - light.turn_on:
              id: button_leds
              effect: "none"
          - light.addressable_set:
              id: button_leds
              range_from: 0
              range_to: 1
              red: 0%
              green: 0%
              blue: 0%
          # Fade Green In
          - light.addressable_set:
              id: button_leds
              range_from: 0
              range_to: 1
              red: 0%
              green: 20%
              blue: 0%
          - delay: 100ms
          - light.addressable_set:
              id: button_leds
              range_from: 0
              range_to: 1
              red: 0%
              green: 60%
              blue: 0%
          - delay: 100ms
          - light.addressable_set:
              id: button_leds
              range_from: 0
              range_to: 1
              red: 0%
              green: 100%
              blue: 0%

  on_stt_end:
    - light.turn_on: 
        id: button_leds
        effect: "Thinking Pulse"

  on_tts_start:
    # Speaking - optionally dim or off. "Off to allow conversation"
    - light.turn_off: button_leds

  on_end:
    # Busy Tone after call (425Hz, 480ms ON, 480ms OFF)
    - lambda: |-
        id(my_tone_gen).set_pulse_timing(480, 480);
        id(my_tone_gen).start_tone(425.0, true);
    - light.turn_off: button_leds

  on_error:
    - light.turn_on: 
        id: button_leds
        effect: "Error Pulse"
    - delay: 2s
    - light.turn_off: button_leds

# Button LEDs
light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: ${pin_led_strip}
    num_leds: 4
    chipset: ws2812
    name: "Button LEDs"
    id: button_leds
    restore_mode: ALWAYS_OFF
    
    # Simulates incandescent fading (Gamma/Tungsten)
    default_transition_length: 0s 

    effects:
      - addressable_scan:
      
      # Mute Pulse (Purple on LED 2 - Index 1)
      - addressable_lambda:
          name: "Mute Pulse"
          update_interval: 50ms # 20fps for smooth animation
          lambda: |-
            static float progress = 0.0;
            static float direction = 0.05;
            
            // Sine-wave approximation for incandescent feel
            progress += direction;
            if (progress > 1.0) { progress = 1.0; direction = -0.05; }
            if (progress < 0.1) { progress = 0.1; direction = 0.05; }
            
            float brightness = progress * progress; // Gamma correctionish
            it.all() = Color::BLACK;
            if (it.size() > 0) it[0] = Color(128, 0, 128) * brightness;

      # Thinking Pulse (Blue on LED 1 - Index 0)
      - addressable_lambda:
          name: "Thinking Pulse"
          update_interval: 50ms
          lambda: |-
            static float progress = 0.0;
            static float direction = 0.1;
            
            progress += direction;
            if (progress > 1.0) { progress = 1.0; direction = -0.05; } // Fast on
            if (progress < 0.0) { progress = 0.0; direction = 0.05; }  // Slow off
            
            float brightness = progress * progress; 
            it.all() = Color::BLACK;
            if (it.size() > 0) it[0] = Color(0, 0, 255) * brightness;

      # Error Pulse (Red on LED 1 - Index 0)
      - addressable_lambda:
          name: "Error Pulse"
          update_interval: 50ms
          lambda: |-
            static float progress = 0.0;
            static float direction = 0.2; // Faster blink
            
            progress += direction;
            if (progress > 1.0) { progress = 1.0; direction = -0.2; }
            if (progress < 0.0) { progress = 0.0; direction = 0.2; }
            
            float brightness = progress * progress;
            it.all() = Color::BLACK;
            if (it.size() > 0) it[0] = Color(255, 0, 0) * brightness;

      # Broadcast Pulse (Yellow on LED 4 - Index 3)
      - addressable_lambda:
          name: "Broadcast Pulse"
          update_interval: 50ms
          lambda: |-
            static float progress = 0.0;
            static float direction = 0.05;
            
            progress += direction;
            if (progress > 1.0) { progress = 1.0; direction = -0.05; }
            if (progress < 0.0) { progress = 0.0; direction = 0.05; }
            
            float brightness = progress * progress;
            it.all() = Color::BLACK;
            if (it.size() > 0) it[0] = Color(255, 200, 0) * brightness;

      # Battery Level Indicator (Static with fade-in on start)
      - addressable_lambda:
          name: "Battery Level"
          update_interval: 500ms
          lambda: |-
            float v = id(battery_voltage).state;
            it.all() = Color::BLACK;
            
            // LED 1 (Red) - < 3.6V (Critical/Low)
            if (v >= 3.0) it[0] = Color(255, 0, 0); 
            
            // LED 2 (Orange) - > 3.6V
            if (v >= 3.6) it[1] = Color(255, 165, 0);
            
            // LED 3 (Yellow) - > 3.8V
            if (v >= 3.8) it[2] = Color(255, 255, 0);
            
            // LED 4 (Green) - > 4.0V
            if (v >= 4.0) it[3] = Color(0, 255, 0);

# Bluetooth for Tracking (Disabled for performance/future option)
# esp32_ble_tracker:
#   scan_parameters:
#     interval: 1100ms
#     window: 1100ms
#     active: true

# bluetooth_proxy:
#   active: true

# I2C Bus Sensoren
i2c:
  sda: ${pin_i2c_sda}
  scl: ${pin_i2c_scl}
  scan: true
  id: bus_a

# Haptic Motor Controller (DRV2605)
drv2605:
  i2c_id: bus_a
  id: haptic_motor
  motor_type: LRA       
  library: 6            # 6 = TS2200_F (LRA library)

# Sensors
text_sensor:
  - platform: template
    name: "Dialed Number String"
    id: dialed_number_string
    icon: "mdi:phone-dial"

sensor:
  - platform: adc
    pin: ${pin_battery_voltage}
    name: "Battery Voltage"
    id: battery_voltage
    update_interval: 60s
    attenuation: 12db
    filters:
      - multiply: 2.0 # Adjust voltage divider factor if needed
    on_value:
      then:
        - if:
            condition:
              lambda: 'return rotary::is_battery_low(x, id(low_battery_threshold).state);'
            then:
              - if:
                  condition:
                    not:
                      script.is_running: led_pulse_red_battery
                  then:
                    - script.execute: led_pulse_red_battery
                    - homeassistant.event:
                        event: esphome.rotary_phone_low_battery
                    - logger.log: "Battery Low! Starting alarm."
            else:
              - if:
                  condition:
                    script.is_running: led_pulse_red_battery
                  then:
                    - script.stop: led_pulse_red_battery
                    - light.addressable_set:
                        id: button_leds
                        range_from: 3
                        range_to: 4
                        red: 0%
                        green: 0%
                        blue: 0%
                    - logger.log: "Battery OK. Stopping alarm."

  - platform: template
    name: "Battery Level"
    id: battery_level
    unit_of_measurement: "%"
    device_class: battery
    accuracy_decimals: 0
    lambda: 'return rotary::get_battery_level(id(battery_voltage).state);'
    update_interval: 60s

  - platform: template
    name: "Last Dialed Digit"
    id: last_dialed_digit
    icon: "mdi:dialpad"
    accuracy_decimals: 0
    force_update: true

  # Globals
globals:
  - id: calculated_ring_delay
    type: int
    initial_value: '0'
  - id: dial_pulse_count
    type: int
    initial_value: '0'
  - id: hook_down_timestamp
    type: unsigned long
    initial_value: '0'
  - id: multi_digit_mode
    type: bool
    restore_value: yes
    initial_value: 'true'
  - id: dialed_number_buffer
    type: std::string
    restore_value: no
    initial_value: '""'
  - id: dial_string_timeout_ms
    type: int
    restore_value: yes
    initial_value: '2000'

  - id: is_muted
    type: bool
    restore_value: no
    initial_value: 'false'
  # Constants
  - id: vibe_loop_duration_ms
    type: int
    initial_value: '750' # 15 vibrations * 50ms

number:
  - platform: template
    name: "Feedback LED Brightness"
    id: feedback_led_brightness
    min_value: 0
    max_value: 100
    step: 5
    initial_value: 50
    optimistic: true
    unit_of_measurement: "%"

  - platform: template
    name: "Ringer Volume"
    id: ringer_volume
    min_value: 0
    max_value: 100
    step: 5
    initial_value: 80
    optimistic: true
    unit_of_measurement: "%"
    on_value:
      then:
        - media_player.volume_set:
            id: media_player_base
            volume: !lambda |-
              return x / 100.0;

  - platform: template
    name: "Low Battery Threshold"
    id: low_battery_threshold
    unit_of_measurement: "%"
    min_value: 5
    max_value: 50
    step: 1
    initial_value: 20
    optimistic: true
    restore_value: true

  - platform: template
    name: "Rotary Phone String Timeout"
    id: rotary_phone_string_timeout
    unit_of_measurement: "ms"
    min_value: 500
    max_value: 10000
    step: 100
    lambda: |-
      return id(dial_string_timeout_ms);
    set_action:
      - globals.set:
          id: dial_string_timeout_ms
          value: !lambda |-
            return x;

  - platform: template
    name: "Ringtone Count"
    id: ring_count
    min_value: 1
    max_value: 20
    step: 1
    initial_value: 5
    optimistic: true
    restore_value: true

  - platform: template
    name: "Ringtone Duration"
    id: ring_duration
    unit_of_measurement: "ms"
    min_value: 1000
    max_value: 10000
    step: 100
    initial_value: 3000
    optimistic: true
    restore_value: true

  - platform: template
    name: "Ringtone Pause"
    id: ring_pause
    unit_of_measurement: "ms"
    min_value: 500
    max_value: 10000
    step: 100
    initial_value: 2000
    optimistic: true
    restore_value: true

  - platform: template
    name: "Max Ringback Loops"
    id: setting_max_rings
    icon: "mdi:phone-ring"
    min_value: 0
    max_value: 6 # 6x Klingeln = ca 24 Sekunden warten
    step: 1
    optimistic: true
    restore_value: true
    initial_value: 2 # Standard: Bis zu 2x Klingeln

  # Speaker Volumes - Updates MuxSpeaker "Volume" variables
  - platform: template
    name: "Volume Handset"
    id: setting_vol_handset
    min_value: 0
    max_value: 200 # Percent
    step: 5
    optimistic: true
    initial_value: 100
    restore_value: true
    entity_category: config
    on_value:
      then:
        - lambda: |-
            static_cast<mux_speaker::MuxSpeaker*>(id(speaker_handset))->set_handset_volume(x / 100.0f);

  - platform: template
    name: "Volume Base"
    id: setting_vol_base
    min_value: 0
    max_value: 200 # Percent
    step: 5
    optimistic: true
    initial_value: 100
    restore_value: true
    entity_category: config
    on_value:
      then:
        - lambda: |-
            static_cast<mux_speaker::MuxSpeaker*>(id(speaker_handset))->set_base_volume(x / 100.0f);

  # Microphone Gains


switch:
  - platform: template
    name: "Microphone Mute"
    id: mic_mute
    icon: "mdi:microphone-off"
    optimistic: true
    on_turn_on:
      - light.turn_on:
          id: button_leds
          effect: "Mute Pulse"
    on_turn_off:
      - light.turn_off: button_leds

  - platform: template
    name: "Speakerphone Mode"
    id: speaker_mode
    icon: "mdi:volume-high"
    optimistic: true

  - platform: template
    name: "Do Not Disturb"
    id: dnd_mode
    icon: "mdi:minus-circle"
    optimistic: true

  - platform: template
    name: "Find R.O.T.A.R.I."
    id: find_rotari_switch
    icon: "mdi:target-variant"
    optimistic: true
    turn_on_action:
      - script.execute: find_phone
    turn_off_action:
      - script.stop: find_phone
      - light.turn_off: button_leds

  - platform: template
    name: "Haptic Ringing"
    id: haptic_ringing
    icon: "mdi:vibrate"
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true

  - platform: template
    name: "Rotary Phone Multi-Digit Mode"
    id: rotary_phone_multi_digit_mode
    optimistic: true
    turn_on_action:
      - globals.set:
          id: multi_digit_mode
          value: 'true'
    turn_off_action:
      - globals.set:
          id: multi_digit_mode
          value: 'false'
      - script.execute: flush_dialed_number

select:
  - platform: template
    name: "Vibration Pattern"
    id: vibration_pattern
    options:
      - "Silent / Classic"
      - "Mechanical Bell"
    optimistic: true
    restore_value: true
    initial_option: "Silent / Classic"
    icon: "mdi:vibrate"

button:
  - platform: restart
    id: sys_restart
    name: "System Restart"

# Scripts
script:
  # Process and send dialed string
  - id: flush_dialed_number
    then:
      - if:
          condition:
            lambda: 'return id(dialed_number_buffer).length() > 0;'
          then:
            - logger.log: 
                format: "Dialed string processing: %s"
                args: [ 'id(dialed_number_buffer).c_str()' ]

            # 1. Fire Home Assistant Event (Logic)
            - homeassistant.event:
                event: esphome.rotary_dial
                data:
                  number: !lambda |-
                    return id(dialed_number_buffer);

            # 2. Update Text Sensor (Display)
            - text_sensor.template.publish:
                id: dialed_number_string
                state: !lambda |-
                  return id(dialed_number_buffer);
            
            # 3. Local System Actions (Low Latency / Offline fallback)
            - if:
                condition:
                   lambda: 'return id(dialed_number_buffer) == "999";'
                then:
                   - logger.log: "Magic Code 999: System Reboot"
                   - button.press: sys_restart
            
            # 4. Clear Buffer & Silence Tone (Ready for TTS)
            - lambda: 'id(my_tone_gen).stop_tone();'
            
            # Logic: Call vs Command
            - if:
                condition:
                  or:
                    - binary_sensor.is_off: phone_hook  # Off-Hook (Abgenommen)
                    - switch.is_on: speaker_mode        # Freisprechen
                then:
                    # ===== CALL MODE (Ringback) =====
                    - lambda: |-
                        int max_r = (int)id(setting_max_rings).state;
                        if (max_r > 0) {
                          id(my_tone_gen).start_ringback_tone();
                          int random_loops = rand() % (max_r + 1);
                          id(calculated_ring_delay) = random_loops * 4000;
                          if (random_loops == 0) id(calculated_ring_delay) = 1500;
                        } else {
                          id(calculated_ring_delay) = 0;
                        }
                    
                    # Wait for ringback
                    - delay: !lambda "return id(calculated_ring_delay);"
                    
                    # Stop Ringback & Click
                    - lambda: 'id(my_tone_gen).stop_tone();'
                    - delay: 100ms
                    - lambda: 'id(my_tone_gen).trigger_click();'
                    - delay: 500ms
                else:
                    # ===== COMMAND MODE (Silent/Instant) =====
                    # Just ensure tone is off
                    - lambda: 'id(my_tone_gen).stop_tone();'
            
            - globals.set:
                id: dialed_number_buffer
                value: !lambda |-
                  return "";
            - text_sensor.template.publish:
                id: dialed_number_string
                state: ""

  - id: flush_dialed_number_timer
    mode: restart
    then:
      - delay: !lambda |-
          return id(dial_string_timeout_ms);
      - script.execute: flush_dialed_number

  # Operator Simulation Script


  # Find My Phone Alarm
  - id: find_phone
    mode: restart
    then:
      - light.turn_on: button_leds
      - while:
          condition:
            lambda: 'return true;'
          then:
            # Ring Logic (Calls ring_phone if not already running)
            - if:
                condition:
                   not:
                     script.is_running: ring_phone
                then:
                   - script.execute: ring_phone

            # Visual Alarm (All 4 LEDs Flash Red)
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 4
                red: 100%
                green: 0%
                blue: 0%
            - delay: 200ms
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 4
                red: 0%
                green: 0%
                blue: 0%
            - delay: 200ms

  - id: process_dialed_digit
    mode: restart
    then:
      - logger.log:
          format: "Rotary Dial: %d pulses counted"
          args: [ 'id(dial_pulse_count)' ]
      
      # Update sensor
      - sensor.template.publish:
          id: last_dialed_digit
          state: !lambda |-
            return (id(dial_pulse_count) == 10) ? 0 : id(dial_pulse_count);

      - if:
          condition:
            lambda: 'return id(dial_pulse_count) > 0;'
          then:
            - if:
                condition:
                  lambda: 'return id(dial_pulse_count) > 20;'
                then:
                  - logger.log: "Ghost pulse detected (Count > 20), ignoring."
                else:
                  # Removed Single-Digit Mode switch.
                  # Always buffering digits now (Phonebook logic).
                  - lambda: |-
                      int count = id(dial_pulse_count);
                      int digit = count;
                      if (count == 10) {
                        digit = 0;
                      }
                      ESP_LOGD("dial_debug", "Pulse Count: %d -> Digit: %d", count, digit);
                      
                      id(dialed_number_buffer) += std::to_string(digit);
                      ESP_LOGD("dial", "Digit added. Buffer: %s", id(dialed_number_buffer).c_str());
                      id(dialed_number_string).publish_state(id(dialed_number_buffer));
                  - script.stop: flush_dialed_number_timer
                  - script.execute: flush_dialed_number_timer
      
      - globals.set:
          id: dial_pulse_count
          value: '0'

  # Ringtone Sequence
  - id: ring_phone
    mode: restart
    then:
      - repeat:
          count: !lambda |-
            return id(ring_count).state;
          then:
            # Check if phone is on hook
            - if:
                condition:
                  binary_sensor.is_on: phone_hook
                then:
                  # Vibration
                  - if:
                      condition:
                        switch.is_on: haptic_ringing
                      then:
                        - if:
                            condition:
                              lambda: 'return id(vibration_pattern).active_index().value_or(0) == 1;'
                            then:
                              - repeat:
                                  count: 25 # Faster, more aggressive for Bell mechanics (Total ~750ms)
                                  then:
                                    - drv2605.play_effect:
                                        id: haptic_motor
                                        effect: 1 # Strong Click
                                    - delay: 30ms
                            else:
                              - repeat:
                                  count: 15 # Classic / Silent (Total ~750ms)
                                  then:
                                    - drv2605.play_effect:
                                        id: haptic_motor
                                        effect: 1 # Strong Click
                                    - delay: 50ms

                  # Wait time compensations: ring_duration - actual_vibration_time
                  - delay: !lambda |-
                      int remaining = id(ring_duration).state - id(vibe_loop_duration_ms);
                      return (remaining < 0) ? 0 : remaining;
                  - delay: !lambda |-
                      return id(ring_pause).state;
                else:
                  - script.stop: ring_phone

  - id: led_pulse_red_battery
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return true;'
          then:
            # Fade in
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 1
                red: 100%
                green: 0%
                blue: 0%
            - delay: 1000ms
            # Fade out
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 1
                red: 10%
                green: 0%
                blue: 0%
            - delay: 1000ms

  - id: led_pulse_purple_mute
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return id(is_muted);'
          then:
            # Fade in (Purple)
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 1
                red: 50%
                green: 0%
                blue: 50%
            - delay: 1000ms
            # Fade out
            - light.addressable_set:
                id: button_leds
                range_from: 0
                range_to: 1
                red: 10%
                green: 0%
                blue: 10%
            - delay: 1000ms

# Binary Sensors
binary_sensor:
  # Hook Switch (Is phone on hook?)
  - platform: gpio
    pin:
      number: ${pin_hook_switch}
      mode: INPUT_PULLUP
      inverted: true
    name: "Phone Hook"
    id: phone_hook
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      # Hook Down (Call ended)
      - lambda: |-
          id(my_tone_gen).trigger_click();
          id(my_tone_gen).stop_tone();
      - voice_assistant.stop:
      - light.turn_off: button_leds
      - globals.set:
          id: hook_down_timestamp
          value: !lambda |-
            return millis();
      - globals.set:
          id: is_muted
          value: 'false'
      - script.stop: led_pulse_purple_mute
    on_release:
      # Hook Up (Call started)
      - if:
          condition:
            lambda: 'return (millis() - id(hook_down_timestamp)) < 500;'
          then:
            # Hook Flash detected
            - logger.log: "Hook Flash detected"
            - homeassistant.event:
                event: esphome.rotary_phone_flash
            # Local Feedback - Click and Restart Tone (Interrupt effect)
            - lambda: |-
                id(my_tone_gen).trigger_click();
                // Restart dial tone to simulate interruption
                id(my_tone_gen).start_tone(425.0);
          else:
            # Normal Pickup
            - if:
                condition:
                  media_player.is_playing: media_player_base
                then:
                  - media_player.stop: media_player_base
            
            # Start Dial Tone (Wait for user input)
            - lambda: 'id(my_tone_gen).start_tone(425.0);'

  # Speed Dial Buttons & Functions
  
  # Button 1: System Control
  - platform: gpio
    pin:
      number: ${pin_button_1}
      mode: INPUT_PULLUP
      inverted: true
    name: "Button 1 (System)"
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_click:
      - min_length: 50ms
        max_length: 500ms
        then:
          - switch.toggle: dnd_mode
          - if:
              condition:
                 switch.is_on: dnd_mode
              then:
                 - logger.log: "DND Enabled"
                 # Optional Red Flash?
              else:
                 - logger.log: "DND Disabled"
      - min_length: 2000ms
        max_length: 10000ms
        then:
          - light.turn_on:
               id: button_leds
               effect: "Battery Level"
          - delay: 3s
          - light.turn_off: button_leds

  # Button 2: Custom Action (HA)
  - platform: gpio
    pin:
      number: ${pin_button_2}
      mode: INPUT_PULLUP
      inverted: true
    name: "Button 2 (Action)"
    filters:
      - delayed_on: 15ms
      - delayed_off: 15ms
    on_press:
      - homeassistant.event:
           event: esphome.rotary_phone_button
           data:
             button: "2"
      - light.addressable_set:
          id: button_leds
          range_from: 1
          range_to: 2
          red: !lambda |-
            return id(feedback_led_brightness).state / 100.0;
          green: !lambda |-
            return (id(feedback_led_brightness).state / 100.0) * 0.8;
          blue: !lambda |-
            return (id(feedback_led_brightness).state / 100.0) * 0.2;
      - delay: 3s
      - light.addressable_set:
          id: button_leds
          range_from: 1
          range_to: 2
          red: 0%
          green: 0%
          blue: 0%

  # Button 3: Custom Action (HA)
  - platform: gpio
    pin:
      number: ${pin_button_3}
      mode: INPUT_PULLUP
      inverted: true
    name: "Button 3 (Action)"
    filters:
      - delayed_on: 15ms
      - delayed_off: 15ms
    on_press:
      - homeassistant.event:
           event: esphome.rotary_phone_button
           data:
             button: "3"
      - light.addressable_set:
          id: button_leds
          range_from: 2
          range_to: 3
          red: !lambda |-
            return id(feedback_led_brightness).state / 100.0;
          green: !lambda |-
            return (id(feedback_led_brightness).state / 100.0) * 0.8;
          blue: !lambda |-
            return (id(feedback_led_brightness).state / 100.0) * 0.2;
      - delay: 3s
      - light.addressable_set:
          id: button_leds
          range_from: 2
          range_to: 3
          red: 0%
          green: 0%
          blue: 0%

  # Button 4: Custom Action (Home Assistant)
  - platform: gpio
    pin:
      number: ${pin_button_4}
      mode: INPUT_PULLUP
      inverted: true
    name: "Button 4 (Action)"
    filters:
      - delayed_on: 15ms
      - delayed_off: 15ms
    # Sends binary_sensor event to HA automatically
    on_press:
      - homeassistant.event:
           event: esphome.rotary_phone_button
           data:
             button: "4"
      - light.addressable_set:
          id: button_leds
          range_from: 3
          range_to: 4
          red: !lambda |-
            return id(feedback_led_brightness).state / 100.0;
          green: !lambda |-
            return (id(feedback_led_brightness).state / 100.0) * 0.8;
          blue: !lambda |-
            return (id(feedback_led_brightness).state / 100.0) * 0.2;
      - delay: 3s
      - light.addressable_set:
          id: button_leds
          range_from: 3
          range_to: 4
          red: 0%
          green: 0%
          blue: 0%

  # Rotary Dial Active (Dial is rotating)
  - platform: gpio
    pin:
      number: ${pin_dial_active}
      mode: INPUT_PULLUP
      inverted: true
    name: "Rotary Dial Active"
    id: rotary_active
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      then:
        - lambda: 'id(my_tone_gen).start_white_noise(0.05);'
        - globals.set:
            id: dial_pulse_count
            value: '0'
        - voice_assistant.stop:
        - script.stop: flush_dialed_number_timer
        - logger.log: "Dialing started..."
    on_release:
      then:
        - logger.log: "Dialing finished."
        - script.execute: process_dialed_digit

  # Rotary Dial Pulse Counting
  - platform: gpio
    pin: 
      number: ${pin_dial_pulse}
      mode: INPUT_PULLUP
      inverted: true
    name: "Rotary Dial Pulse"
    id: rotary_pulse
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      then:
        # Acoustic tick (Click)
        - lambda: 'id(my_tone_gen).trigger_click();'
        - globals.set:
            id: dial_pulse_count
            value: !lambda |-
              return id(dial_pulse_count) + 1;
