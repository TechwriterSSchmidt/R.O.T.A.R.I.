# Hardware Pin Definitions
# Change these values here to adapt to different board revisions
substitutions:
  # I2S Audio - Handset (Microphone & Ear Speaker)
  pin_i2s_handset_lrclk: GPIO5
  pin_i2s_handset_bclk: GPIO6
  pin_i2s_handset_din: GPIO7   # Mic Data In
  pin_i2s_handset_dout: GPIO15 # Speaker Data Out

  # I2S Audio - Base (Main Speaker for Ringtone/Music)
  pin_i2s_base_lrclk: GPIO16
  pin_i2s_base_bclk: GPIO18
  pin_i2s_base_dout: GPIO19

  # Peripherals
  pin_battery_voltage: GPIO4
  
  # LED Pins (4 separate pins)
  pin_led_1: GPIO2  # Status LED (GPIO38 is input-only on S3)
  pin_led_2: GPIO3  # Button 2 (moved to output-capable pin)
  pin_led_3: GPIO20 # Button 3 (moved to output-capable pin)
  pin_led_4: GPIO17 # Button 4 (moved to output-capable pin)
  
  # I2C Bus
  pin_i2c_sda: GPIO8
  pin_i2c_scl: GPIO9

  # Rotary Phone Mechanism
  pin_hook_switch: GPIO1      # Detects if handset is on hook
  pin_dial_pulse: GPIO14      # Dial pulse counting
  pin_dial_active: GPIO13     # Active while dial is rotating
  
  # Speed Dial Buttons
  pin_button_1: GPIO10
  pin_button_2: GPIO11
  pin_button_3: GPIO12
  pin_button_4: GPIO21 # Adjust if necessary

# External Components
external_components:
  - source:
      type: local
      path: components
    components: [ drv2605, vintage_tone_generator, mux_speaker ]

esp32:
  board: esp32-s3-devkitc-1
  flash_size: 16MB
  partitions: default_16MB.csv
  framework:
    type: arduino

# Enable logging (default 115200)
logger:
  hardware_uart: USB_CDC
  level: DEBUG

# Boot Animation
esphome:
  name: rotary-phone-agent
  friendly_name: "R.O.T.A.R.I."
  min_version: 2024.7.0
  includes:
    - src/rotary_helpers.h
    - components/mux_speaker/mux_speaker.h
  platformio_options:
    board_build.flash_mode: dio
    # Generic ESP32-S3 16MB Flash / 8MB PSRAM Specifics
    board_build.arduino.memory_type: qio_opi
    build_flags:
      - "-DBOARD_HAS_PSRAM"
      - "-DARDUINO_USB_CDC_ON_BOOT=1"
  on_boot:
    priority: -100
    then:
      - script.execute: boot_animation

# Enable Home Assistant API
api:
  reboot_timeout: 5min
  services:
    - service: start_find_my_phone
      then:
        - script.execute: find_phone
    - service: stop_find_my_phone
      then:
        - script.stop: find_phone
        - light.turn_off: led_status
    - service: start_broadcast_notification
      then:
        - light.turn_on:
            id: led_status
            effect: "Broadcast Pulse"
    - service: stop_broadcast_notification
      then:
        - light.turn_off: led_status
    - service: start_listening
      then:
        - voice_assistant.start

# Enable OTA updates
ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  reboot_timeout: 5min

  # Captive Portal Fallback
  ap:
    ssid: "Rotary-Phone-Agent Fallback"
    password: "" # Consider moving this to secrets if security is a concern

captive_portal:

# Voice Assistant configuration
# Requires a microphone and speaker (e.g., I2S based like INMP441 and MAX98357A)

# I2S Bus A: Handset
i2s_audio:
  - id: i2s_bus_handset
    i2s_lrclk_pin: ${pin_i2s_handset_lrclk}
    i2s_bclk_pin: ${pin_i2s_handset_bclk}

  # I2S Bus B: Base Speaker
  - id: i2s_bus_base
    i2s_lrclk_pin: ${pin_i2s_base_lrclk}
    i2s_bclk_pin: ${pin_i2s_base_bclk}

microphone:
  - platform: i2s_audio
    id: mic_i2s
    i2s_audio_id: i2s_bus_handset
    i2s_din_pin: ${pin_i2s_handset_din}
    adc_type: external
    pdm: false

vintage_tone_generator:
  id: my_tone_gen
  i2s_audio_id: i2s_bus_handset

speaker:
  # Handset Speaker (Standard for Voice Assistant)
  #- platform: i2s_audio
  #  id: speaker_handset
  #  i2s_audio_id: i2s_bus_handset
  #  i2s_dout_pin: ${pin_i2s_handset_dout}
  #  dac_type: external
  
  # Smart Mux Speaker (Routing based on Mode)
  - platform: mux_speaker
    id: speaker_handset # Keeping ID for compatibility
    handset_bus: i2s_bus_handset
    base_bus: i2s_bus_base
    mode_switch: speaker_mode
    # Note: Standard I2S pins are defined in i2s_audio components,
    # and this virtual speaker routes writes to them.
    # We must ensure the actual I2S buses are initialized.



# Media Player for Ringtones & Music (Base Speaker)
media_player:
  - platform: i2s_audio
    name: "Rotary Phone Base Speaker"
    id: media_player_base
    i2s_audio_id: i2s_bus_base
    i2s_dout_pin: ${pin_i2s_base_dout}
    dac_type: external
    mode: mono
    on_play:
      - light.turn_on:
          id: led_status
          effect: "none"
          brightness: 100%
          red: 0%
          green: 0%
          blue: 100% # Blue for Music/Ringing
    on_idle:
      - light.turn_off: led_status

voice_assistant:
  microphone: mic_i2s
  auto_gain: 0dBFS
  speaker: speaker_handset # Respond only via Handset
  on_start:
    - if:
        condition:
          switch.is_on: dnd_mode
        then:
          - voice_assistant.stop:
          - logger.log: "Voice Assistant blocked because of DND"
          - light.turn_on:
              id: led_status
              effect: "DND Pulse"
        else:
          - light.turn_on:
              id: led_status
              effect: "none"
              brightness: 100%
              red: 0%
              green: 0%
              blue: 100% # Listening = Blue Static

  on_stt_end:
    - light.turn_on: 
        id: led_status
        effect: "Thinking Pulse"

  on_tts_start:
    # Speaking - optionally dim or off. "Off to allow conversation"
    - light.turn_on:
        id: led_status
        effect: "none"
        brightness: 100%
        red: 0%
        green: 0%
        blue: 100% # Speaking = Blue


  on_end:
    # Busy Tone after call (425Hz, 480ms ON, 480ms OFF)
    - lambda: |-
        id(my_tone_gen).set_pulse_timing(480, 480);
        id(my_tone_gen).start_tone(425.0, true);
    - light.turn_off: led_status

  on_error:
    - light.turn_on: 
        id: led_status
        effect: "Error Pulse"
    - delay: 2s
    - light.turn_off: led_status

# LED Configuration (4 Separate Neopixels)
light:
  # LED 1: Status / Voice Assistant (The "Smart" LED)
  - platform: neopixelbus
    type: GRB
    variant: WS2812
    method: ESP32_RMT_0
    pin: ${pin_led_1}
    num_leds: 1
    name: "Status LED"
    id: led_status
    restore_mode: ALWAYS_OFF
    effects:
      - pulse:
          name: "Thinking Pulse"
          transition_length: 500ms
          update_interval: 1000ms
          min_brightness: 10%
          max_brightness: 100%
      - pulse:
          name: "DND Pulse"
          transition_length: 1000ms # Slow breathing
          update_interval: 2000ms
      - strobe:
          name: "Error Pulse"
          colors:
            - state: true
              brightness: 100%
              red: 100%
              green: 0%
              blue: 0%
              duration: 200ms
            - state: false
              duration: 200ms
      - pulse: 
          name: "Find Phone Pulse"
          transition_length: 100ms
          update_interval: 750ms
      - pulse:
          name: "Broadcast Pulse"
          transition_length: 300ms
          update_interval: 300ms
      - addressable_lambda:
          name: "Battery Level"
          update_interval: 1s
          lambda: |-
            if (id(battery_level).state > 50) {
              it[0] = Color(0, 255, 0);
            } else if (id(battery_level).state > 20) {
              it[0] = Color(255, 165, 0);
            } else {
              it[0] = Color(255, 0, 0);
            }

  # LED 2: Button 2 Feedback (Mute/Action)
  - platform: neopixelbus
    type: GRB
    variant: WS2812
    method: ESP32_RMT_1
    pin: ${pin_led_2}
    num_leds: 1
    name: "Button 2 LED"
    id: led_btn_2
    restore_mode: ALWAYS_OFF
    effects:
      - pulse:
          name: "Mute Pulse" # Optional if used later
          
  # LED 3: Button 3 Feedback
  - platform: neopixelbus
    type: GRB
    variant: WS2812
    method: ESP32_RMT_2
    pin: ${pin_led_3}
    num_leds: 1
    name: "Button 3 LED"
    id: led_btn_3
    restore_mode: ALWAYS_OFF

  # LED 4: Button 4 Feedback
  - platform: neopixelbus
    type: GRB
    variant: WS2812
    method: ESP32_RMT_3
    pin: ${pin_led_4}
    num_leds: 1
    name: "Button 4 LED"
    id: led_btn_4
    restore_mode: ALWAYS_OFF

# I2C Bus Sensoren
i2c:
  sda: ${pin_i2c_sda}
  scl: ${pin_i2c_scl}
  scan: true
  id: bus_a

# Haptic Motor Controller (DRV2605)
drv2605:
  i2c_id: bus_a
  id: haptic_motor
  motor_type: LRA       
  library: 6            # 6 = TS2200_F (LRA library)

# Sensors
text_sensor:
  - platform: template
    name: "Dialed Number String"
    id: dialed_number_string
    icon: "mdi:phone-dial"

sensor:
  - platform: adc
    pin: ${pin_battery_voltage}
    name: "Battery Voltage"
    id: battery_voltage
    update_interval: 60s
    attenuation: 12db
    filters:
      - multiply: 2.0 # Adjust voltage divider factor if needed
    on_value:
      then:
        - if:
            condition:
              lambda: 'return rotary::is_battery_low(x, id(low_battery_threshold).state);'
            then:
              - if:
                  condition:
                    lambda: 'return id(led_status).get_effect_name() != "Error Pulse";'
                  then:
                    - light.turn_on:
                        id: led_status
                        effect: "Error Pulse"
                    - homeassistant.event:
                        event: esphome.rotary_phone_low_battery
                    - logger.log: "Battery Low! Starting alarm."
            else:
              - if:
                  condition:
                    lambda: 'return id(led_status).get_effect_name() == "Error Pulse";'
                  then:
                    - light.turn_on:
                        id: led_status
                        effect: "none"
                    # Restore battery view momentarily or just off
                    - light.turn_off: led_status
                    - logger.log: "Battery OK. Stopping alarm."

  - platform: template
    name: "Battery Level"
    id: battery_level
    unit_of_measurement: "%"
    device_class: battery
    accuracy_decimals: 0
    lambda: 'return rotary::get_battery_level(id(battery_voltage).state);'
    update_interval: 60s

  - platform: template
    name: "Last Dialed Digit"
    id: last_dialed_digit
    icon: "mdi:dialpad"
    accuracy_decimals: 0
    force_update: true

  # Globals
globals:
  - id: calculated_ring_delay
    type: int
    initial_value: '0'
  - id: dial_pulse_count
    type: int
    initial_value: '0'
  - id: hook_down_timestamp
    type: unsigned long
    initial_value: '0'
  - id: dialed_number_buffer
    type: std::string
    restore_value: no
    initial_value: '""'
  - id: dial_string_timeout_ms
    type: int
    restore_value: yes
    initial_value: '2000'

  - id: is_muted
    type: bool
    restore_value: no
    initial_value: 'false'
  # Constants
  - id: vibe_loop_duration_ms
    type: int
    initial_value: '750' # 15 vibrations * 50ms

number:
  - platform: template
    name: "Feedback LED Brightness"
    id: feedback_led_brightness
    min_value: 0
    max_value: 100
    step: 5
    initial_value: 50
    optimistic: true
    unit_of_measurement: "%"

  - platform: template
    name: "Ringer Volume"
    id: ringer_volume
    min_value: 0
    max_value: 100
    step: 5
    initial_value: 80
    optimistic: true
    unit_of_measurement: "%"
    on_value:
      then:
        - media_player.volume_set:
            id: media_player_base
            volume: !lambda |-
              return x / 100.0;

  - platform: template
    name: "Low Battery Threshold"
    id: low_battery_threshold
    unit_of_measurement: "%"
    min_value: 5
    max_value: 50
    step: 1
    initial_value: 20
    optimistic: true
    restore_value: true

  - platform: template
    name: "Rotary Phone String Timeout"
    id: rotary_phone_string_timeout
    unit_of_measurement: "ms"
    min_value: 500
    max_value: 10000
    step: 100
    lambda: |-
      return id(dial_string_timeout_ms);
    set_action:
      - globals.set:
          id: dial_string_timeout_ms
          value: !lambda |-
            return x;

  - platform: template
    name: "Ringtone Count"
    id: ring_count
    min_value: 1
    max_value: 20
    step: 1
    initial_value: 5
    optimistic: true
    restore_value: true

  - platform: template
    name: "Ringtone Duration"
    id: ring_duration
    unit_of_measurement: "ms"
    min_value: 1000
    max_value: 10000
    step: 100
    initial_value: 3000
    optimistic: true
    restore_value: true

  - platform: template
    name: "Ringtone Pause"
    id: ring_pause
    unit_of_measurement: "ms"
    min_value: 500
    max_value: 10000
    step: 100
    initial_value: 2000
    optimistic: true
    restore_value: true

  - platform: template
    name: "Max Ringback Loops"
    id: setting_max_rings
    icon: "mdi:phone-ring"
    min_value: 0
    max_value: 6 # 6x Klingeln = ca 24 Sekunden warten
    step: 1
    optimistic: true
    restore_value: true
    initial_value: 2 # Standard: Bis zu 2x Klingeln

  # Speaker Volumes - Updates MuxSpeaker "Volume" variables
  - platform: template
    name: "Volume Handset"
    id: setting_vol_handset
    min_value: 0
    max_value: 200 # Percent
    step: 5
    optimistic: true
    initial_value: 100
    restore_value: true
    entity_category: config
    on_value:
      then:
        - lambda: |-
            static_cast<mux_speaker::MuxSpeaker*>(id(speaker_handset))->set_handset_volume(x / 100.0f);

  - platform: template
    name: "Volume Base"
    id: setting_vol_base
    min_value: 0
    max_value: 200 # Percent
    step: 5
    optimistic: true
    initial_value: 100
    restore_value: true
    entity_category: config
    on_value:
      then:
        - lambda: |-
            static_cast<mux_speaker::MuxSpeaker*>(id(speaker_handset))->set_base_volume(x / 100.0f);

  # Microphone Gains


switch:
  - platform: template
    name: "Do Not Disturb"
    id: dnd_mode
    icon: "mdi:minus-circle"
    optimistic: true
    on_turn_on:
      - light.turn_on:
          id: led_status
          effect: "DND Pulse"
    on_turn_off:
      - light.turn_off: led_status

  - platform: template
    name: "Hands-free Mode"
    id: speaker_mode
    icon: "mdi:volume-high"
    optimistic: true
    on_turn_on:
      - light.turn_on:
          id: led_status
          effect: "none"
          brightness: 100%
          red: 0%
          green: 100%
          blue: 0%
    on_turn_off:
      - light.turn_off: led_status

  - platform: template
    name: "Find R.O.T.A.R.I."
    id: find_rotari_switch
    icon: "mdi:target-variant"
    optimistic: true
    turn_on_action:
      - script.execute: find_phone
    turn_off_action:
      - script.stop: find_phone
      - light.turn_off: led_status

  - platform: template
    name: "Haptic Ringing"
    id: haptic_ringing
    icon: "mdi:vibrate"
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true


select:
  - platform: template
    name: "Vibration Pattern"
    id: vibration_pattern
    options:
      - "Silent / Classic"
      - "Mechanical Bell"
    optimistic: true
    restore_value: true
    initial_option: "Silent / Classic"
    icon: "mdi:vibrate"

button:
  - platform: restart
    id: sys_restart
    name: "System Restart"

# Scripts
script:
  # Boot Animation (Chase Effect over 4 simple LEDs)
  - id: boot_animation
    then:
      - light.turn_on:
          id: led_status
          brightness: 100%
          red: 100% 
          green: 65% 
          blue: 0%
      - delay: 150ms
      - light.turn_off: led_status
      - light.turn_on:
          id: led_btn_2
          brightness: 100%
          red: 100% 
          green: 65% 
          blue: 0%
      - delay: 150ms
      - light.turn_off: led_btn_2
      - light.turn_on:
          id: led_btn_3
          brightness: 100%
          red: 100% 
          green: 65% 
          blue: 0%
      - delay: 150ms
      - light.turn_off: led_btn_3
      - light.turn_on:
          id: led_btn_4
          brightness: 100%
          red: 100% 
          green: 65% 
          blue: 0%
      - delay: 150ms
      - light.turn_off: led_btn_4

  # Process and send dialed string
  - id: flush_dialed_number
    then:
      - if:
          condition:
            lambda: 'return id(dialed_number_buffer).length() > 0;'
          then:
            - logger.log: 
                format: "Dialed string processing: %s"
                args: [ 'id(dialed_number_buffer).c_str()' ]

            # 1. Fire Home Assistant Event (Logic)
            - homeassistant.event:
                event: esphome.rotary_dial
                data:
                  number: !lambda |-
                    return id(dialed_number_buffer);

            # 2. Update Text Sensor (Display)
            - text_sensor.template.publish:
                id: dialed_number_string
                state: !lambda |-
                  return id(dialed_number_buffer);
            
            # 3. Local System Actions (Low Latency / Offline fallback)
            - if:
                condition:
                   lambda: 'return id(dialed_number_buffer) == "999";'
                then:
                   - logger.log: "Magic Code 999: System Reboot"
                   - button.press: sys_restart
            
            # 4. Clear Buffer & Silence Tone (Ready for TTS)
            # - lambda: 'id(my_tone_gen).stop_tone();'
            
            # Logic: Call vs Command
            - if:
                condition:
                  or:
                    - binary_sensor.is_off: phone_hook  # Off-Hook (Abgenommen)
                    - switch.is_on: speaker_mode        # Freisprechen
                then:
                    # ===== CALL MODE (Ringback) =====
                    # - lambda: |-
                    #     int max_r = (int)id(setting_max_rings).state;
                    #     if (max_r > 0) {
                    #       id(my_tone_gen).start_ringback_tone();
                    #       int random_loops = rand() % (max_r + 1);
                    #       id(calculated_ring_delay) = random_loops * 4000;
                    #       if (random_loops == 0) id(calculated_ring_delay) = 1500;
                    #     } else {
                    #       id(calculated_ring_delay) = 0;
                    #     }
                    
                    # Wait for ringback
                    - delay: !lambda "return id(calculated_ring_delay);"
                    
                    # Stop Ringback & Click
                    # - lambda: 'id(my_tone_gen).stop_tone();'
                    - delay: 100ms
                    # - lambda: 'id(my_tone_gen).trigger_click();'
                    - delay: 500ms
                else:
                    # ===== COMMAND MODE (Silent/Instant) =====
                    # Just ensure tone is off
                    # - lambda: 'id(my_tone_gen).stop_tone();'
            
            - globals.set:
                id: dialed_number_buffer
                value: !lambda |-
                  return "";
            - text_sensor.template.publish:
                id: dialed_number_string
                state: ""

  - id: flush_dialed_number_timer
    mode: restart
    then:
      - delay: !lambda |-
          return id(dial_string_timeout_ms);
      - script.execute: flush_dialed_number

  # Operator Simulation Script


  # Find My Phone Alarm
  - id: find_phone
    mode: restart
    then:
      - light.turn_on: 
          id: led_status
          effect: "Find Phone Pulse"
      - while:
          condition:
            lambda: 'return true;'
          then:
            # Ring Logic (Calls ring_phone if not already running)
            - if:
                condition:
                   not:
                     script.is_running: ring_phone
                then:
                   - script.execute: ring_phone
            
            # Just wait, LED effect handles the pulsing now
            - delay: 1s

  - id: process_dialed_digit
    mode: restart
    then:
      - logger.log:
          format: "Rotary Dial: %d pulses counted"
          args: [ 'id(dial_pulse_count)' ]
      
      # Update sensor
      - sensor.template.publish:
          id: last_dialed_digit
          state: !lambda |-
            return (id(dial_pulse_count) == 10) ? 0 : id(dial_pulse_count);

      - if:
          condition:
            lambda: 'return id(dial_pulse_count) > 0;'
          then:
            - if:
                condition:
                  lambda: 'return id(dial_pulse_count) > 20;'
                then:
                  - logger.log: "Ghost pulse detected (Count > 20), ignoring."
                else:
                  # Always buffering digits now (Phonebook logic).
                  - lambda: |-
                      int count = id(dial_pulse_count);
                      int digit = count;
                      if (count == 10) {
                        digit = 0;
                      }
                      ESP_LOGD("dial_debug", "Pulse Count: %d -> Digit: %d", count, digit);
                      
                      id(dialed_number_buffer) += std::to_string(digit);
                      ESP_LOGD("dial", "Digit added. Buffer: %s", id(dialed_number_buffer).c_str());
                      id(dialed_number_string).publish_state(id(dialed_number_buffer));
                  - script.stop: flush_dialed_number_timer
                  - script.execute: flush_dialed_number_timer
      
      - globals.set:
          id: dial_pulse_count
          value: '0'

  # Ringtone Sequence
  - id: ring_phone
    mode: restart
    then:
      - if:
          condition:
            and:
              - not:
                  switch.is_on: find_rotari_switch
              - not:
                  script.is_running: find_phone
          then:
            - light.turn_on:
                id: led_status
                effect: "none"
                brightness: 100%
                red: 100%
                green: 40%
                blue: 0%  # Amber/Gold for incoming call
      - repeat:
          count: !lambda |-
            return id(ring_count).state;
          then:
            # Check if phone is on hook
            - if:
                condition:
                  binary_sensor.is_on: phone_hook
                then:
                  # Vibration
                  - if:
                      condition:
                        and:
                          - switch.is_on: haptic_ringing
                          - not:
                              switch.is_on: dnd_mode
                      then:
                        - if:
                            condition:
                              lambda: 'return id(vibration_pattern).active_index().value_or(0) == 1;'
                            then:
                              - repeat:
                                  count: 25 # Faster, more aggressive for Bell mechanics (Total ~750ms)
                                  then:
                                    - drv2605.play_effect:
                                        id: haptic_motor
                                        effect: 1 # Strong Click
                                    - delay: 30ms
                            else:
                              - repeat:
                                  count: 15 # Classic / Silent (Total ~750ms)
                                  then:
                                    - drv2605.play_effect:
                                        id: haptic_motor
                                        effect: 1 # Strong Click
                                    - delay: 50ms

                  # Wait time compensations: ring_duration - actual_vibration_time
                  - delay: !lambda |-
                      int remaining = id(ring_duration).state - id(vibe_loop_duration_ms);
                      return (remaining < 0) ? 0 : remaining;
                  - delay: !lambda |-
                      return id(ring_pause).state;
                else:
                  - script.stop: ring_phone
      
      - light.turn_off: led_status


# Binary Sensors
binary_sensor:
  # Hook Switch (Is phone on hook?)
  - platform: gpio
    pin:
      number: ${pin_hook_switch}
      mode: INPUT_PULLUP
      inverted: true
    name: "Phone Hook"
    id: phone_hook
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      # Hook Down (Call ended)
      - logger.log: "Hook Down. Killing all audio."
      # - lambda: |-
      #     id(my_tone_gen).trigger_click();
      #     id(my_tone_gen).stop_tone();
      
      # 1. Stop AI (Highest Priority)
      # - voice_assistant.stop:

      # 2. Stop Handset Audio (Voice Assistant is already stopped above)
      
      # 3. Stop Base Speaker Audio (Music/Announcements)
      # - media_player.stop: media_player_base

      # 4. Stop Ringing / Alarms

      - script.stop: ring_phone
      - script.stop: find_phone
      
      # 5. Stop Dial Buffer flushing
      - script.stop: flush_dialed_number_timer
      - script.stop: flush_dialed_number

      # 6. Visual Cleanup
      - light.turn_off: led_status
      # - script.stop: led_pulse_purple_mute
      
      # 7. Reset Internal State
      - globals.set:
          id: hook_down_timestamp
          value: !lambda |-
            return millis();
      # - globals.set:
      #     id: is_muted
      #     value: 'false'

    on_release:
      # Hook Up (Call started)
      - if:
          condition:
            lambda: 'return (millis() - id(hook_down_timestamp)) < 500;'
          then:
            # Hook Flash detected
            - logger.log: "Hook Flash detected"
            - homeassistant.event:
                event: esphome.rotary_phone_flash
            # Local Feedback - Click and Restart Tone (Interrupt effect)
            # - lambda: |-
            #     id(my_tone_gen).trigger_click();
            #     // Restart dial tone to simulate interruption
            #     id(my_tone_gen).start_tone(425.0);
          else:
            # Normal Pickup (Answer Call / Start Dialing)
            - script.stop: ring_phone
            - script.stop: find_phone
            
            - if:
                condition:
                  media_player.is_playing: media_player_base
                then:
                  - media_player.stop: media_player_base
            
            # Start Dial Tone (Wait for user input)
            # - lambda: 'id(my_tone_gen).start_tone(425.0);'

  # Speed Dial Buttons & Functions
  
  # Button 1: System Control
  - platform: gpio
    pin:
      number: ${pin_button_1}
      mode: INPUT_PULLUP
      inverted: true
    name: "Button 1 (System)"
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_click:
      - min_length: 50ms
        max_length: 500ms
        then:
          - switch.toggle: dnd_mode
          - if:
              condition:
                 switch.is_on: dnd_mode
              then:
                 - logger.log: "DND Enabled"
                 # Optional Red Flash?
              else:
                 - logger.log: "DND Disabled"
      - min_length: 2000ms
        max_length: 10000ms
        then:
        - light.turn_on:
              id: led_status
              effect: "Battery Level"
        - delay: 3s
        - light.turn_off: led_status

  # Button 2: Custom Action (HA)
  - platform: gpio
    pin:
      number: ${pin_button_2}
      mode: INPUT_PULLUP
      inverted: true
    name: "Button 2 (Action)"
    filters:
      - delayed_on: 15ms
      - delayed_off: 15ms
    on_press:
      - homeassistant.event:
           event: esphome.rotary_phone_button
           data:
             button: "2"
      - light.turn_on:
          id: led_btn_2
          effect: "none"
          brightness: !lambda |-
            return id(feedback_led_brightness).state / 100.0;
          red: 100%
          green: 80%
          blue: 20%
      - delay: 3s
      - light.turn_off: led_btn_2

  # Button 3: Custom Action (HA)
  - platform: gpio
    pin:
      number: ${pin_button_3}
      mode: INPUT_PULLUP
      inverted: true
    name: "Button 3 (Action)"
    filters:
      - delayed_on: 15ms
      - delayed_off: 15ms
    on_press:
      - homeassistant.event:
           event: esphome.rotary_phone_button
           data:
             button: "3"
      - light.turn_on:
          id: led_btn_3
          effect: "none"
          brightness: !lambda |-
            return id(feedback_led_brightness).state / 100.0;
          red: 100%
          green: 80%
          blue: 20%
      - delay: 3s
      - light.turn_off: led_btn_3

  # Button 4: Custom Action (Home Assistant)
  - platform: gpio
    pin:
      number: ${pin_button_4}
      mode: INPUT_PULLUP
      inverted: true
    name: "Button 4 (Action)"
    filters:
      - delayed_on: 15ms
      - delayed_off: 15ms
    # Sends binary_sensor event to HA automatically
    on_press:
      - homeassistant.event:
           event: esphome.rotary_phone_button
           data:
             button: "4"
      - light.turn_on:
          id: led_btn_4
          effect: "none"
          brightness: !lambda |-
            return id(feedback_led_brightness).state / 100.0;
          red: 100%
          green: 80%
          blue: 20%
      - delay: 3s
      - light.turn_off: led_btn_4

  # Rotary Dial Active (Dial is rotating)
  - platform: gpio
    pin:
      number: ${pin_dial_active}
      mode: INPUT_PULLUP
      inverted: true
    name: "Rotary Dial Active"
    id: rotary_active
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      then:
        # - lambda: 'id(my_tone_gen).start_white_noise(0.05);'
        - globals.set:
            id: dial_pulse_count
            value: '0'
        # - voice_assistant.stop:
        - script.stop: flush_dialed_number_timer
        - logger.log: "Dialing started..."
    on_release:
      then:
        - logger.log: "Dialing finished."
        - script.execute: process_dialed_digit

  # Rotary Dial Pulse Counting
  - platform: gpio
    pin: 
      number: ${pin_dial_pulse}
      mode: INPUT_PULLUP
      inverted: true
    name: "Rotary Dial Pulse"
    id: rotary_pulse
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      then:
        # Acoustic tick (Click)
        # - lambda: 'id(my_tone_gen).trigger_click();'
        - globals.set:
            id: dial_pulse_count
            value: !lambda |-
              return id(dial_pulse_count) + 1;
